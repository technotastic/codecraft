--- START FILE: tsconfig.node.json ---
// tsconfig.node.json
{
    // No "extends"
    "compilerOptions": {
      "composite": true,            // Required by referencing config
      "module": "CommonJS",         // Correct for Node/Electron main/preload
      "moduleResolution": "Node",   // Correct module resolution
      "target": "ESNext",           // Target modern JS for Electron
      "lib": ["ESNext", "DOM"],     // Include necessary libs

      "noEmit": false,              // We MUST emit JS files
      "outDir": "dist-electron",    // Output directory
      "rootDir": "src",             // Source root directory

      /* Base URL and Paths are needed if using aliases within main/preload code */
      "baseUrl": ".",               // Define baseUrl if using paths
      "paths": {                    // Keep paths if used within main/preload code
        "@renderer/*": ["src/renderer/*"],
        "@main/*": ["src/main/*"],
        "@preload/*": ["src/preload/*"]
        //"@shared/*": ["src/shared/*"]
      },

      "strict": true,                 // Enable strict checks
      "esModuleInterop": true,        // Recommended for CJS/ESM interop
      "forceConsistentCasingInFileNames": true, // Good practice
      "skipLibCheck": false,          // *** Temporarily FALSE to force checks/emission ***

      /* Node/Electron Specific Overrides */
      "allowImportingTsExtensions": false, // No .ts imports in CJS output
      "resolveJsonModule": true,          // Allow importing JSON
      "isolatedModules": false            // Not isolated modules
    },
    // Includes - Define what this config compiles
    "include": [
      "src/main/**/*.ts",             // Compile main process code
      "src/preload/**/*.ts",          // Compile preload code
      "src/shared.types.ts"           // Compile shared types if they exist (remove if not)
    ],
    // Excludes - Define what NOT to compile
    "exclude": [
      "node_modules",                 // Standard excludes
      "dist",
      "dist-electron",                // Exclude output from input
      "src/renderer"                  // Exclude renderer code
    ]
  }
--- END FILE: tsconfig.node.json ---

--- START FILE: text.txt ---

---

**Project Continuation Prompt: CodeCraft IDE (State after Reverting Failed 'Save As...' Attempt)**

**1. Project Goal:**
To build a functional desktop code editor (CodeCraft IDE) using Electron, React, TypeScript, and Vite, featuring an integrated terminal, file management, and basic customization.

**2. Core Technologies:**
*   **Framework:** Electron
*   **UI (Renderer):** React, TypeScript, Vite
*   **Editor Component:** Monaco Editor (`react-monaco-editor`)
*   **Terminal Component:** Xterm.js + `node-pty` (via IPC)
*   **Layout:** `allotment`
*   **Styling:** CSS Variables, Theme Context

**3. Current Stable State Summary:**

*   **Development Environment:** Manual setup using Vite dev server (`dev:vite`), `tsc --watch` for main/preload (`dev:main`), and `electron .` (`start`) in separate terminals.
*   **Architecture:**
    *   **Main Process (`main/index.ts`):** Handles window (starts fullscreen), app menu, IPC (dialogs, multi-PTY, filesystem), basic app controls.
    *   **Preload Script (`preload/index.ts`):** Securely exposes typed `electronAPI` via `contextBridge` for all renderer-main communication.
    *   **Renderer Process (`renderer/`):** React app managed by Vite.
*   **Key Features Implemented & Stable:**
    *   **Layout:** Resizable horizontal split (Sidebar/Main Area) and vertical split (Editor/Terminal Area) using `Allotment`.
    *   **Theming:** `ThemeContext` manages theme name (e.g., 'dark', 'pipboy', 'win95') and font size modifier. Applies `.theme-*` class to root/body. Includes a `CustomSelect` dropdown in the sidebar for theme switching. Base editor/terminal background/foreground colors update correctly.
    *   **Contexts:** `ThemeContext`, `EditorContext`, `TerminalContext` manage relevant application state.
    *   **Sidebar:**
        *   Displays an expandable file tree (`FileTreeNode`) populated via `fs:readDirectory` IPC. Fetching children on expansion works.
        *   Supports "Open Folder..." to set the tree root.
        *   Supports navigating up directories.
        *   Clicking files opens them in the editor via `fs:readFile` IPC and `EditorContext`.
    *   **Editor Area:**
        *   Managed by `EditorContext`, supporting multiple file tabs (`TabContainer`, `Tab`).
        *   Handles opening, closing, and focusing tabs.
        *   Tracks and displays file dirty status (`*`) on tabs.
        *   **Saving Confirmed Working:** Saving files via Ctrl+S (`fs:saveFile` IPC) reliably updates the file content and context state. Stale state issues previously encountered are resolved.
        *   Renders Monaco Editor instance (`EditorPanel`).
        *   Basic language detection based on file extension (used for status bar display).
    *   **Terminal Area:**
        *   Managed by `TerminalContext`, supports multiple terminal tabs (`TerminalTabContainer`, `TerminalTab`) via '+' button.
        *   Renders Xterm.js instances (`TerminalPanel`) per tab, managing visibility via CSS.
        *   Multi-instance PTY communication via IPC (`pty-create`, `pty-input`, etc.) is functional.
        *   Terminal background/foreground colors update based on the selected app theme.
        *   **Rendering Issues Fixed:** Resolved previous issues with blank screens, color bleeding, and cursor offsets on tab switching.
        *   **Clear Terminal Button Added & Functional:** The button in the active terminal panel correctly clears the xterm instance via context/events.
    *   **Status Bar:**
        *   Implemented (`StatusBar.tsx`, `StatusBar.css`) and displays active file name, dirty status, error status, cursor line/column, basic detected language, live time, and placeholder encoding.
*   **Development Server Interaction:** Saving the root `index.html` during development correctly triggers a Vite full page reload (expected behavior).

**4. Known Issues / Regressions & Failed Attempts:**

*   **Syntax Highlighting (BROKEN):**
    *   While base Monaco themes (background, foreground, selection) are applied correctly via CSS vars and `defineTheme` in `EditorPanel.tsx` (on mount), token-based syntax highlighting does not work.
    *   Token colors (for keywords, strings, comments, etc.) do not appear correctly for any language.
    *   Switching application themes does *not* update token colors.
    *   **Multiple previous attempts to fix this (by adding `rules` to `defineTheme` and trying dynamic theme redefinition) have failed, sometimes breaking base theme colors.** Extreme caution is required here.
*   **"Save As..." Feature Attempt (FAILED & REVERTED):**
    *   An attempt to implement "Save As..." functionality (involving menu changes, new IPC dialog, context updates) resulted in a **blank screen** on application startup.
    *   **These changes have been fully reverted.** The codebase is back to the state *before* this attempt.

**5. V1 Goals Status (Reflecting Current State):**

*   Functional Monaco Editor (Partially Done - multi-file, saving fixed. **Highlighting broken.** "Save As..." failed.)
*   Integrated Terminal (Done - multi-tab, rendering fixed, clear button added)
*   File Tree/Management (Done - basic open/read/display/save)
*   Theming (Foundation done. **Syntax highlighting broken.** Advanced features deferred.)
*   Font Size Control (Done)
*   Movable/Resizable Panels (Done)
*   Status Bar (Done)

**6. Next Steps / Potential Tasks (Prioritization Needed):**

*   **(CRITICAL BUG) Fix Syntax Highlighting:** Re-attempt diagnosing why token colors aren't working/updating. Needs a *different approach* than previous attempts, focusing on reliability and avoiding regressions. Potentially explore simpler theme application methods if `defineTheme` proves too fragile with dynamic CSS vars.
*   **(MED) Implement "Save As..." Functionality:** Re-attempt this feature, carefully diagnosing the cause of the previous blank-screen failure. Needs meticulous implementation and testing.
*   **(MED) Editor Polish:**
    *   Wire up Edit Menu items (Undo/Redo integration - investigate Monaco's built-in support).
*   **(MED) Terminal Polish:**
    *   Improve visual feedback for exited terminal processes (beyond tab title).
*   **(MED) Main Menu / Accelerators:** Review standard menu items and accelerators for correctness and platform consistency.
*   **(MED) Error Handling:** Improve user feedback for filesystem/PTY errors beyond current basic messages.
*   **(LOW) File Management Extras:** New File/Folder, Delete, Rename.
*   **(LOW) Theming - VS Code Import:** Parse `.json` themes.
*   **(LOW) Font Loading:** Robust custom font loading.

**7. Future Ideas Brainstorm:**
*   Project-wide Search (`ripgrep`)
*   Git Integration (Status, Basic Commands)
*   Command Palette (Ctrl+Shift+P)
*   Snippets
*   Debugger Integration (DAP)
*   Plugin System
*   Settings UI (`electron-store`)
*   Remote/SSH Integration
*   Web Version (`vscode-web`)
*   AI Code Assistance
*   Markdown Preview
*   Advanced Layouts (`react-mosaic`)

**8. Action Requested for Next Session:**

Given the current stable state (with working save, terminal, file tree) but the critically broken syntax highlighting and the recent catastrophic failures when attempting fixes/features:

*   **What is the *single*, most impactful, and **absolutely safest** feature or fix to attempt next?**
*   **Strongly consider:**
    *   Prioritizing stability above all else.
    *   Choosing a task with minimal dependencies on complex state interactions or component lifecycles.
    *   Potentially breaking down larger goals (like highlighting or "Save As...") into much smaller, verifiable steps if attempting them again.
*   **Any proposed solution MUST:**
    *   Clearly explain *why* it is safe and unlikely to cause regressions based on past failures.
    *   Be conceptually simple and testable in isolation if possible.

---

This prompt provides a much clearer picture of the validated working parts, the specific known failures, and sets a strong expectation for stability and caution in the next interaction. Hopefully, this helps us move forward more reliably.
---


*** BELOW ARE ALL OLDER PROMPTS, AND CAN BE IGNORED ***



**Project Continuation Prompt: CodeCraft IDE**

**1. Project Goal:**
To build a functional desktop code editor (CodeCraft IDE) using Electron, React, TypeScript, and Vite, featuring an integrated terminal, file management, and basic customization.

**2. Core Technologies:**
*   **Framework:** Electron
*   **UI (Renderer):** React, TypeScript, Vite
*   **Editor Component:** Monaco Editor (`react-monaco-editor`)
*   **Terminal Component:** Xterm.js + `node-pty` (via IPC)
*   **Layout:** `allotment`
*   **Styling:** CSS Variables, Theme Context

**3. Current State Summary:**

*   **Development Environment:** Manual setup using Vite dev server (`dev:vite`), `tsc --watch` for main/preload (`dev:main`), and `electron .` (`start`) in separate terminals.
*   **Architecture:**
    *   **Main Process (`main/index.ts`):** Handles window (starts fullscreen), app menu, IPC (dialogs, multi-PTY, filesystem), basic app controls.
    *   **Preload Script (`preload/index.ts`):** Securely exposes typed `electronAPI` via `contextBridge` for all renderer-main communication.
    *   **Renderer Process (`renderer/`):** React app managed by Vite.
*   **Key Features Implemented:**
    *   **Layout:** Resizable horizontal split (Sidebar/Main Area) and vertical split (Editor/Terminal Area) using `Allotment`.
    *   **Theming:** `ThemeContext` manages theme name (e.g., 'dark', 'pipboy', 'win95') and font size modifier. Applies `.theme-*` class to root/body. Includes a `CustomSelect` dropdown in the sidebar for theme switching.
    *   **Contexts:** `ThemeContext`, `EditorContext`, `TerminalContext` manage relevant application state.
    *   **Sidebar:**
        *   Displays an expandable file tree (`FileTreeNode`) populated via `fs:readDirectory` IPC.
        *   Supports "Open Folder..." to set the tree root.
        *   Supports navigating up directories.
        *   Clicking files opens them in the editor via `fs:readFile` IPC and `EditorContext`.
    *   **Editor Area:**
        *   Managed by `EditorContext`, supporting multiple file tabs (`TabContainer`, `Tab`).
        *   Handles opening, closing, and focusing tabs.
        *   Tracks and displays file dirty status (`*`) on tabs.
        *   **Saving Fixed:** Saving files via Ctrl+S (`fs:saveFile` IPC) now reliably updates the file content and context state. Stale state issues resolved.
        *   Renders Monaco Editor instance (`EditorPanel`).
        *   Basic language detection based on file extension (used for status bar display).
        *   **Syntax Highlighting:** **NOT FUNCTIONAL.** While basic Monaco themes (background, foreground) are applied, token-based syntax highlighting does not change with themes or work correctly.
    *   **Terminal Area:**
        *   Managed by `TerminalContext`, supports multiple terminal tabs (`TerminalTabContainer`, `TerminalTab`) via '+' button.
        *   Renders Xterm.js instances (`TerminalPanel`) per tab, managing visibility via CSS.
        *   Multi-instance PTY communication via IPC (`pty-create`, `pty-input`, etc.) is functional.
        *   Terminal background/foreground colors update based on the selected app theme.
        *   **Rendering Issues Fixed:** Resolved previous issues with blank screens, color bleeding, and cursor offsets on tab switching.
    *   **Status Bar:**
        *   Implemented (`StatusBar.tsx`, `StatusBar.css`).
        *   Displays active file name, dirty status, error status.
        *   Displays cursor line/column number.
        *   Displays basic detected language of the active file.
        *   Displays live-updating current time.
        *   Displays placeholder encoding (UTF-8).
*   **Development Server Interaction:** Saving the root `index.html` during development correctly triggers a Vite full page reload (expected behavior).

**4. V1 Goals Status:**
*   Functional Monaco Editor (Partially Done - multi-file, saving fixed. **Highlighting broken.**)
*   Integrated Terminal (Done - multi-tab, rendering fixed)
*   File Tree/Management (Done - basic open/read/display/save)
*   Theming (Foundation done. **Syntax highlighting broken.** Advanced features deferred.)
*   Font Size Control (Done)
*   Movable/Resizable Panels (Done)
*   Status Bar (Done)

**5. Next Steps to Implement (Suggestions):**

*   **(HIGH) Fix Syntax Highlighting:** Diagnose why token colors aren't being applied correctly or changing with themes. Revisit theme definition in `EditorPanel.tsx` (`monaco.editor.defineTheme`) and ensure `rules` are correctly structured and map to theme variables.
*   **(HIGH) Editor Polish (After Highlighting Fixed):**
    *   Wire up Edit Menu items (Undo/Redo integration).
    *   Implement "Save As..." functionality.
*   **(HIGH) Terminal Polish:**
    *   Add "Clear Terminal" command/button.
    *   Improve visual feedback for exited terminal processes.
*   **(MED) Main Menu / Accelerators:** Review standard menu items and accelerators for correctness and platform consistency.
*   **(MED) Error Handling:** Improve user feedback for filesystem/PTY errors.
*   **(LOW) File Management Extras:** New File/Folder, Delete, Rename.
*   **(LOW) Theming - VS Code Import:** Parse `.json` themes.
*   **(LOW) Font Loading:** Robust custom font loading.

**6. Future Ideas Brainstorm:**
*   Project-wide Search (`ripgrep`)
*   Git Integration (Status, Basic Commands)
*   Command Palette (Ctrl+Shift+P)
*   Snippets
*   Debugger Integration (DAP)
*   Plugin System
*   Settings UI (`electron-store`)
*   Remote/SSH Integration
*   Web Version (`vscode-web`)
*   AI Code Assistance
*   Markdown Preview
*   Advanced Layouts (`react-mosaic`)

**7. Action Requested:**
Based on the current state, particularly the non-functional syntax highlighting, what feature or fix should be prioritized next? (Fixing syntax highlighting is highly recommended).



*** OLDER PROMPTS BELOW - LEFT FOR REFERENCE****


Okay, my apologies for the previous incorrect assessment. Saving is a core function, and if it's broken, that needs to be the absolute top priority. I've updated the prompt to reflect this critical bug.

---

**Continuation Prompt for CodeCraft IDE Development**

**Project:** CodeCraft IDE - A desktop IDE using Electron, React, TypeScript.

**Current Status:**
The development environment uses a manual Vite configuration with a multi-terminal workflow (`dev:main`, `dev:vite`, `start`). The core architecture is functional, but **critical bugs exist**:

*   **Main Process (`src/main/index.ts`):** Handles window creation (starts fullscreen), standard application menu, IPC handling (Ping, Dialogs), manages multiple `node-pty` instances mapped by unique IDs, and handles filesystem operations (read dir/file, save file) via IPC. Hardware acceleration is disabled.
*   **Preload Script (`src/preload/index.ts`):** Exposes a type-safe `electronAPI` via `contextBridge` for all required IPC communication, including multi-terminal management, filesystem access, dialogs, and basic app/window controls.
*   **Renderer Process (`src/renderer`):** Uses React, TypeScript, and Vite.
    *   **Layout:** Uses `Allotment` for resizable horizontal (Sidebar/MainPanel) and vertical (Editor/Terminal Area) splits.
    *   **Theming:** Uses `ThemeContext` for managing theme name and font size modifier. Theme classes (`.theme-*`) applied dynamically. `CustomSelect` used for theme switching.
    *   **Contexts:** `ThemeContext`, `EditorContext`, `TerminalContext` are implemented.
    *   **Sidebar:** Features a working file tree (`FileTreeNode`) populated via IPC (`fs:readDirectory`), supporting directory expansion. Open folder functionality populates the tree root. Clicking files opens them in the editor via `EditorContext` / `fs:readFile`. Up-directory navigation works. Contains theme switcher.
    *   **Editor Area:**
        *   Managed by `EditorContext`, supports multiple file tabs (`TabContainer`, `Tab`).
        *   Handles opening, closing, focusing tabs, tracking dirty state (visible on tab).
        *   **BUG:** File saving (`fs:saveFile` IPC / Ctrl+S) is **NOT working correctly**. Reports indicate it fails to save changes.
        *   Renders a functional Monaco Editor instance (`EditorPanel`).
        *   Basic language detection based on file extension is active.
        *   *Syntax highlighting customization deferred.*
    *   **Terminal Area:**
        *   Managed by `TerminalContext`, supports multiple terminal tabs (`TerminalTabContainer`, `TerminalTab`) with a '+' button.
        *   Renders functional Xterm.js instances (`TerminalPanel`) for each tab using CSS visibility/layering.
        *   Backend PTY communication via IPC is functional and multi-instance aware.
        *   Terminal theme colors update based on the selected app theme.
        *   **Fixed:** Rendering glitches (blank screen, background color bleed, cursor offset) when switching tabs.
        *   **Fixed:** Width issues for full-screen terminal applications (e.g., `lynx`).

**Key Recent Achievements:**
*   Successfully implemented multi-terminal tabs.
*   Resolved terminal rendering and width issues upon tab switching.

**V1 Goals Recap (Updated Status):**
*   Functional Monaco Editor (Partially Done - multi-file tabs, basic highlighting. **Saving broken.**)
*   Integrated Terminal (xterm+node-pty) (Done - multi-terminal tabs, rendering/width fixed)
*   File Tree/Management (Partially Done - open folder, read dir/file, display tree. **Saving broken.**)
*   Theming (Foundation done. *Advanced features deferred.*)
*   Font Size Control (Done)
*   Movable/Resizable Panels (Done)

**Next Steps to Implement:**

1.  **(CRITICAL) Fix File Saving:**
    *   Diagnose why the `activeFileNow.isDirty` check in `EditorPanel.tsx`'s Ctrl+S handler might be failing or why the `saveActiveFile` function in `EditorContext.tsx` isn't successfully triggering the `fs:saveFile` IPC call or processing its response correctly.
    *   Use console logs extensively in `handleInternalChange` (EditorPanel), `updateActiveFileDirtyState` (EditorContext), the Ctrl+S handler (EditorPanel), and `saveActiveFile` (EditorContext) to trace the `isDirty` state and the save attempt flow.
    *   Verify the `fs:saveFile` IPC handler in `main/index.ts` is receiving the correct path and content and not encountering filesystem errors (permissions, etc.).
    *   Ensure the `content` state in `EditorContext` is correctly updated *after* a successful save to reset the dirty state.

2.  **(HIGH) Editor Polish (After Save Fixed):**
    *   Implement a **Status Bar** component.
    *   Wire up relevant **Edit Menu** items.
    *   Consider "Save As..." functionality.

3.  **(HIGH) Terminal Polish:**
    *   Add a "Clear Terminal" button/command.
    *   Improve visual indication when a terminal process has exited.

4.  **(MED) Theming - Syntax Highlighting Customization:**
    *   Revisit `EditorPanel.tsx` and add/refine `rules` in `defineTheme`.

5.  **(MED) Main Menu Integration & Accelerators:**
    *   Review menu items and ensure they trigger correct actions.
    *   Verify standard keyboard accelerators.

6.  **(MED) Error Handling:**
    *   Improve user feedback for errors (file ops, PTY).

7.  **(LOW) Theming - VS Code Import:**
    *   Implement IPC and parsing logic for `.json` themes.

8.  **(LOW) File Management Extras:**
    *   New File, New Folder, Delete, Rename.

9.  **(LOW) Font Loading:**
    *   Implement robust loading/fallback for custom fonts.

**Question:** The **absolute priority** is fixing the file saving functionality (Step 1).

---

**Future Ideas / "Cool Stuff" Brainstorm:**

*   **Search:** Implement project-wide text search (potentially using `ripgrep` via IPC). Find/Replace within the current editor file (using Monaco's built-in actions).
*   **Git Integration:** Display Git status in the file tree/status bar, provide basic Git commands (commit, push, pull) via UI elements and IPC calls to the `git` CLI.
*   **Command Palette:** Add a VS Code-style command palette (Ctrl+Shift+P) for quick access to commands (Open File, Change Theme, Git commands, etc.).
*   **Snippets:** Support for user-defined code snippets.
*   **Debugger Integration:** Integrate a debugger for a specific language (e.g., Node.js) using the Debug Adapter Protocol (DAP) - complex.
*   **Extensibility/Plugin System:** Design a basic plugin system to allow adding custom functionality or themes (very advanced).
*   **Settings UI:** Create a dedicated UI panel for managing settings (theme, font size, editor options, terminal options) instead of just the theme dropdown. Persist settings using `electron-store` or similar.
*   **Remote Development/SSH:** Allow opening folders and running terminals over SSH connections.
*   **Web Version:** Explore using the same codebase (with adjustments for Node APIs) to build a web-based version using something like `vscode-web`.
*   **AI Code Assistance:** Integrate with AI APIs (like CodeLlama, GitHub Copilot APIs, etc.) for code suggestions and completion (requires API keys, careful implementation).
*   **Markdown Preview:** Add a live preview panel for Markdown files.
*   **Improved Layout Options:** Use libraries like `react-mosaic` for more complex draggable/dockable panel layouts.


----


** BELOW THIS LINE IN THIS FILE IS OLD HISTORY **



---

**Continuation Prompt for CodeCraft IDE Development**

**Project:** CodeCraft IDE - A desktop IDE using Electron, React, TypeScript.

**Current Status:**
We have successfully set up the development environment using a manual Vite configuration with a multi-terminal workflow:
1.  Terminal 1: `npm run dev:main` (Compiles `src/main` and `src/preload` via `tsc --watch`)
2.  Terminal 2: `npm run dev:vite` (Runs Vite dev server via `vite`)
3.  Terminal 3: `npm start` (Launches the Electron app via `electron .`)

The application structure includes:
*   **Main Process (`src/main/index.ts`):** Handles window creation, IPC (Ping, PTY management, Dialog), application menu creation (File, Edit, View with Theme submenu), and `node-pty` management. Compiles to CommonJS. Hardware acceleration disabled.
*   **Preload Script (`src/preload/index.ts`):** Exposes an `electronAPI` via `contextBridge` for IPC (Ping, PTY, Dialog, Menu Theme/Open Folder actions). Compiles to CommonJS.
*   **Renderer Process (`src/renderer`):** Uses React, TypeScript, and Vite.
    *   **Layout:** Uses `Allotment` for a resizable vertical split between the Editor and Terminal panels, inside a main content area next to a fixed `Sidebar`.
    *   **Theming:**
        *   Uses React Context (`ThemeContext`) to manage the current theme name (`light`, `dark`, `win95`, `pipboy`, `mirc`).
        *   Applies theme classes (`.theme-*`) to the root and body elements.
        *   `index.css` defines extensive CSS variables and specific style overrides for each theme.
        *   Includes a custom React dropdown component (`CustomSelect.tsx`) for theme switching in the `Sidebar`.
        *   Top application menu (`View > Theme`) reflects and can set the current theme.
    *   **Editor Panel:** Renders a functional Monaco Editor instance using `react-monaco-editor`. Basic custom Monaco themes are defined and applied based on the selected app theme (e.g., `pipboy-monaco-theme`).
    *   **Terminal Panel:** Renders a functional Xterm.js terminal using manual `Terminal` instantiation and `FitAddon`. The terminal's colors are updated based on the selected app theme. IPC bridge (`pty-create`, `pty-input`, `pty-resize`, `pty-data`, `pty-exit`) is functional. Resizing via `FitAddon` and IPC is handled.
    *   **Sidebar:** Contains a placeholder for the file tree and the custom theme switcher dropdown.

**Key Dependencies Installed:** `electron`, `react`, `typescript`, `vite`, `monaco-editor`, `react-monaco-editor`, `xterm`, `xterm-addon-fit`, `node-pty`, `allotment`, `electron-squirrel-startup`.

**V1 Goals Recap (Original + New):**
*   Functional Monaco Editor (Done - basic)
*   Integrated Terminal (xterm+node-pty) (Done - basic)
*   File Tree/Management (Not started)
*   Theming (Foundation done: CSS Vars, aesthetic themes, VS Code compatible base needed)
*   Font Size Control (To be implemented)
*   Movable/Resizable Panels (Partially done - vertical split)

**Next Steps to Implement:**

1.  **File Management (Core Functionality):**
    *   **Sidebar UI:** Replace placeholder with a file/folder listing component.
    *   **Open Folder:** Wire up the "File > Open Folder..." menu item (and/or add a button) to trigger `dialog:openDirectory` IPC, store the selected path in the renderer state/context.
    *   **Read Directory:** Implement IPC handler (`fs:read-directory`) in main using Node `fs` to read contents of the selected path. Send file/folder list back.
    *   **Display Tree:** Populate Sidebar component with the list, make it expandable/collapsible.
    *   **Read File:** IPC handler (`fs:read-file`) in main to read file content.
    *   **Load in Editor:** On file click, trigger `fs:read-file` IPC, update Monaco Editor value and language mode.
    *   **Save File:** IPC handler (`fs:save-file`) in main. Add save mechanism (Ctrl+S, menu) in renderer to send content/path.
    *   **(Optional)** Tabs for multiple open files.

2.  **Theming System (Phase 2 - VS Code Integration):**
    *   IPC handlers for opening/reading VS Code theme `.json` files.
    *   Main process parser to extract colors (`workbench.colorCustomizations`, `tokenColors`).
    *   Map VS Code keys to our CSS variables & Monaco theme keys.
    *   Dynamically update CSS variables and apply `monaco.editor.defineTheme`.

3.  **Theming System (Phase 3 - Refinements):**
    *   Refine aesthetic theme definitions (CSS and Monaco) for better accuracy/completeness.
    *   Handle font loading robustly.

4.  **Font Size Control:**
    *   Re-implement a robust font size control mechanism (e.g., using context, updating CSS variables, ensuring editor/terminal resize correctly).

5.  **Layout Enhancements:**
    *   Consider adding horizontal splitting (e.g., Sidebar vs Main Content Area) using `Allotment`.
    *   Explore more complex layouts if needed (e.g., multiple editor groups like VS Code, potentially using React-Mosaic).

6.  **Terminal Refinements:**
    *   Improve visual handling of the `pty-exit` event.
    *   Add a "clear terminal" command/button.

7.  **Editor Enhancements:**
    *   Configure more Monaco options (minimap, word wrap, etc.).
    *   Indicate unsaved changes.

**Question:** Which of these next steps should we focus on now? (File Management is strongly recommended as the next core feature).

---
--- END FILE: text.txt ---

--- START FILE: index.html ---
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" /> <!-- Example icon -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CodeCraft IDE (TS)</title>
  </head>
  <body>
    <!-- The root element where React app mounts -->
    <!-- The ThemeProvider will add theme classes here -->
    <div id="root"></div>
    <!-- Entry point script for the renderer process -->
    <script type="module" src="/src/renderer/main.tsx"></script>
  </body>
</html>
--- END FILE: index.html ---

--- START FILE: test.txt ---
Testing testing 123

321 gnitset gnitseT
--- END FILE: test.txt ---

--- START FILE: tsconfig.json ---
// tsconfig.json (Base config)
{
    "compilerOptions": {
      "target": "ESNext",
      "lib": ["DOM", "DOM.Iterable", "ESNext"],
      "module": "ESNext",
      "skipLibCheck": true,
      "moduleResolution": "bundler",
      "allowImportingTsExtensions": true,
      "resolveJsonModule": true,
      "isolatedModules": true,
      "noEmit": true, // Renderer code emitted by Vite
      "jsx": "react-jsx",
      "esModuleInterop": true,
      "forceConsistentCasingInFileNames": true,
      "strict": true,
      "noUnusedLocals": true,
      "noUnusedParameters": true,
      "noFallthroughCasesInSwitch": true,
      "baseUrl": ".",
      "paths": {
        "@renderer/*": ["src/renderer/*"],
        "@main/*": ["src/main/*"],
        "@preload/*": ["src/preload/*"]
        //"@shared/*": ["src/shared/*"]
      }
    },
    "include": [
      "src/renderer/**/*.ts",
      "src/renderer/**/*.tsx",
      "src/renderer/vite-env.d.ts", // Adjusted path
      "src/shared.types.ts" // If it exists and is used by renderer
     ],
    "references": [{ "path": "./tsconfig.node.json" }] // Needs composite:true in node config
  }
--- END FILE: tsconfig.json ---

--- START FILE: release/0.1.0/builder-effective-config.yaml ---
directories:
  output: release/${version}
  buildResources: assets
appId: com.example.codecraftide
productName: CodeCraft IDE
files:
  - filter:
      - dist/**/*
      - dist-electron/**/*
      - index.html
      - package.json
win:
  target: nsis
  icon: assets/icon.ico
mac:
  target: dmg
  icon: assets/icon.icns
linux:
  target: AppImage
  icon: assets/icon.png
nsis:
  oneClick: false
  allowToChangeInstallationDirectory: true
electronVersion: 30.5.1
--- END FILE: release/0.1.0/builder-effective-config.yaml ---

--- START FILE: vite.config.mjs ---
// --- START FILE: vite.config.mjs ---
// vite.config.mjs
import { defineConfig } from 'vite';
import path from 'node:path';
import react from '@vitejs/plugin-react';
import monacoEditorPlugin from 'vite-plugin-monaco-editor';
// *** CHANGE THIS IMPORT ***
// import nodePolyfills from 'vite-plugin-node-stdlib-browser';
import { nodePolyfills } from 'vite-plugin-node-polyfills'; // Import the new plugin


// Define __dirname for ES module scope
import { fileURLToPath } from 'node:url';
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);


// Helper to access the actual plugin function
const resolveMonacoPlugin = (pluginImport) => {
  if (typeof pluginImport === 'function') return pluginImport;
  if (pluginImport && typeof pluginImport.default === 'function') return pluginImport.default;
  console.error("Could not resolve monaco editor plugin function!");
  return pluginImport;
};
const actualMonacoPlugin = resolveMonacoPlugin(monacoEditorPlugin);


export default defineConfig({
  plugins: [
    react(),
    actualMonacoPlugin({ /* ... */ }),
    // *** Use the new plugin ***
    nodePolyfills({
      // Options (optional):
      // To exclude specific polyfills, add them to this list.
      // For example, if you don't want process polyfilled:
      // exclude: ['process'],
      // To include globals like Buffer and process:
      globals: {
        Buffer: true, // Default: true
        global: true, // Default: true
        process: true, // Default: true
      },
      // Whether to polyfill `node:` protocol imports.
      protocolImports: true, // Default: true
    })
  ],
  build: {
    outDir: 'dist/renderer',
    emptyOutDir: true,
  },
  resolve: {
    alias: {
      '@renderer': path.resolve(__dirname, './src/renderer'),
      '@main': path.resolve(__dirname, './src/main'),
      '@preload': path.resolve(__dirname, './src/preload'),
      // Let the plugin handle polyfills
    },
  },
  root: '.',
  base: './',
  server: {
     strictPort: true,
     hmr: {}
   },
  optimizeDeps: {}
});
// --- END FILE: vite.config.mjs ---
--- END FILE: vite.config.mjs ---

--- START FILE: src/renderer/path-browserify.d.ts ---
// src/renderer/path-browserify.d.ts
declare module 'path-browserify';
--- END FILE: src/renderer/path-browserify.d.ts ---

--- START FILE: src/renderer/contexts/TerminalContext.tsx ---
// --- START FILE: src/renderer/contexts/TerminalContext.tsx ---
import React, {
  createContext,
  useState,
  useContext,
  ReactNode,
  useCallback,
  useMemo,
  useRef,
  useEffect,
} from "react";
import { v4 as uuidv4 } from "uuid"; // Use UUID for unique IDs

// Define the structure for an open terminal session
export interface OpenTerminal {
  id: string;
  title: string;
  isLoading: boolean; // Is the backend PTY starting up?
  isReady: boolean; // Has the backend PTY confirmed creation?
  exitCode?: number | null; // Store exit code if process terminates (null means exited normally with 0 or unknown, number is specific code)
  error?: string | null; // Store any errors related to this terminal
}

// Define the shape of the context properties
interface TerminalContextProps {
  openTerminals: OpenTerminal[];
  activeTerminalId: string | null;
  createTerminal: (initialCols?: number, initialRows?: number) => void;
  closeTerminal: (terminalId: string) => void;
  setActiveTerminal: (terminalId: string | null) => void;
  writeToActiveTerminal: (data: string) => void;
  resizeActiveTerminal: (cols: number, rows: number) => void;
  clearActiveTerminal: () => void; // <<< NEW FUNCTION ADDED
  getActiveTerminal: () => OpenTerminal | undefined;
}

// Create the context
const TerminalContext = createContext<TerminalContextProps | undefined>(
  undefined
);

// Define the props for the provider component
interface TerminalProviderProps {
  children: ReactNode; // Prop type for children components
}

// Create the provider component
export const TerminalProvider: React.FC<TerminalProviderProps> = ({
  children,
}) => {
  const [openTerminals, setOpenTerminals] = useState<OpenTerminal[]>([]);
  const [activeTerminalId, setActiveTerminalId] = useState<string | null>(null);
  const globalListenersAttached = useRef(false);

  // Helper to update a specific terminal in the state
  const updateTerminalState = useCallback(
    (terminalId: string, updates: Partial<OpenTerminal>) => {
      setOpenTerminals((prevTerminals) =>
        prevTerminals.map((term) =>
          term.id === terminalId ? { ...term, ...updates } : term
        )
      );
    },
    []
  ); // No dependencies needed as setOpenTerminals is stable

  // Helper to get the active terminal object
  const getActiveTerminal = useCallback((): OpenTerminal | undefined => {
    return openTerminals.find((t) => t.id === activeTerminalId);
  }, [openTerminals, activeTerminalId]); // Depends on these state values

  // Function to create a new terminal tab and request backend PTY
  const createTerminal = useCallback(
    async (initialCols: number = 80, initialRows: number = 24) => {
      const newId = uuidv4();
      // Default title based on the number of terminals *about* to exist
      const newTerminalTitle = `Terminal ${openTerminals.length + 1}`;
      const newTerminal: OpenTerminal = {
        id: newId,
        title: newTerminalTitle,
        isLoading: true,
        isReady: false,
        error: null,
        exitCode: undefined, // Use undefined initially to mean "not exited"
      };

      console.log(
        `TerminalContext: Creating new terminal tab (ID: ${newId}, Title: ${newTerminalTitle})`
      );
      // Update state first
      setOpenTerminals((prev) => [...prev, newTerminal]);
      setActiveTerminalId(newId); // Make the new terminal active immediately

      // Request backend PTY creation
      console.log(`TerminalContext: Requesting backend PTY for ID ${newId}...`);
      try {
        // Ensure cols/rows are valid before sending
        const colsToSend = Math.max(1, initialCols);
        const rowsToSend = Math.max(1, initialRows);
        const result = await window.electronAPI.term_create({
          id: newId,
          cols: colsToSend,
          rows: rowsToSend,
        });
        if (result?.success) {
          console.log(
            `TerminalContext: Backend PTY creation request successful for ID ${newId}`
          );
          // Mark as ready now that the main process acknowledged creation
          updateTerminalState(newId, {
            isLoading: false,
            isReady: true,
            error: null,
          });
        } else {
          console.error(
            `TerminalContext: Backend PTY creation failed for ID ${newId}:`,
            result?.error
          );
          updateTerminalState(newId, {
            isLoading: false,
            isReady: false,
            error: `Backend Error: ${result?.error || "Unknown error"}`,
          });
        }
      } catch (err) {
        const errorMsg = err instanceof Error ? err.message : String(err);
        console.error(
          `TerminalContext: IPC Error creating PTY for ID ${newId}:`,
          errorMsg
        );
        updateTerminalState(newId, {
          isLoading: false,
          isReady: false,
          error: `IPC Error: ${errorMsg}`,
        });
      }
    },
    [openTerminals.length, updateTerminalState]
  ); // Dependency on length for title, and update helper

  // Function to close a terminal tab and kill backend PTY
  const closeTerminal = useCallback(
    async (terminalId: string) => {
      console.log(
        `TerminalContext: Requesting to close terminal ID: ${terminalId}`
      );
      // Find the index BEFORE filtering, needed for setting the next active tab
      const terminalToCloseIndex = openTerminals.findIndex(
        (t) => t.id === terminalId
      );
      const terminalToClose = openTerminals[terminalToCloseIndex];

      if (terminalToCloseIndex === -1 || !terminalToClose) {
        console.warn(
          `TerminalContext: Cannot close terminal ID ${terminalId}, not found.`
        );
        return;
      }

      // Remove from renderer state
      const remainingTerminals = openTerminals.filter(
        (t) => t.id !== terminalId
      );
      setOpenTerminals(remainingTerminals);

      // Determine next active terminal if the closed one was active
      if (activeTerminalId === terminalId) {
        let nextActiveId: string | null = null;
        if (remainingTerminals.length > 0) {
          // Try to activate the tab that was visually before the closed one,
          // otherwise the new last tab. Max(0,...) handles closing the first tab.
          const nextIndex = Math.min(
            remainingTerminals.length - 1,
            Math.max(0, terminalToCloseIndex - 1)
          );
          nextActiveId = remainingTerminals[nextIndex]?.id || null;
        }
        console.log(
          `TerminalContext: Setting next active terminal to: ${nextActiveId}`
        );
        setActiveTerminalId(nextActiveId); // Update active ID state
      }

      // Tell main process to kill the backend PTY
      // Only kill if it seems like it could be running (was ready or loading AND hasn't reported an exit code yet)
      if (
        (terminalToClose.isReady || terminalToClose.isLoading) &&
        terminalToClose.exitCode === undefined
      ) {
        console.log(
          `TerminalContext: Sending kill request for backend PTY ID: ${terminalId}`
        );
        try {
          await window.electronAPI.term_kill(terminalId);
          console.log(
            `TerminalContext: Backend kill request acknowledged for ID: ${terminalId}`
          );
        } catch (err) {
          console.error(
            `TerminalContext: IPC Error sending kill request for PTY ID ${terminalId}:`,
            err
          );
        }
      } else {
        console.log(
          `TerminalContext: No kill request needed for ID ${terminalId} (state: isLoading=${terminalToClose.isLoading}, isReady=${terminalToClose.isReady}, exitCode=${terminalToClose.exitCode}).`
        );
      }
    },
    [openTerminals, activeTerminalId, setActiveTerminalId]
  ); // Depends on state and the setter for active ID

  // Function to set the active terminal
  const setActiveTerminal = useCallback(
    (terminalId: string | null) => {
      // Prevent unnecessary state updates if already active
      if (terminalId !== activeTerminalId) {
        console.log(
          `TerminalContext: Setting active terminal ID to: ${terminalId}`
        );
        setActiveTerminalId(terminalId);
      }
    },
    [activeTerminalId]
  ); // Depends only on activeTerminalId for comparison

  // Function to send data to the *active* terminal's backend PTY
  const writeToActiveTerminal = useCallback(
    (data: string) => {
      if (!activeTerminalId) {
        console.warn("TerminalContext: Cannot write data, no active terminal.");
        return;
      }
      // Find the active terminal to ensure it's ready and not exited before sending
      const activeTerm = openTerminals.find((t) => t.id === activeTerminalId); // Use raw state here
      if (activeTerm?.isReady && activeTerm.exitCode === undefined) {
        // console.log(`TerminalContext: Writing data to active terminal ID ${activeTerminalId}`); // Very verbose
        window.electronAPI.term_write(activeTerminalId, data);
      } else {
        console.warn(
          `TerminalContext: Cannot write data, active terminal ${activeTerminalId} not ready or has exited.`
        );
      }
    },
    [activeTerminalId, openTerminals]
  ); // Depends on activeId and the list to find the term

  // Function to resize the *active* terminal's backend PTY
  const resizeActiveTerminal = useCallback(
    (cols: number, rows: number) => {
      if (!activeTerminalId) {
        console.warn("TerminalContext: Cannot resize, no active terminal.");
        return;
      }
      // Ensure cols/rows are valid positive numbers
      if (cols <= 0 || rows <= 0) {
        console.warn(
          `TerminalContext: Attempted to resize terminal ${activeTerminalId} with invalid dimensions: ${cols}x${rows}`
        );
        return;
      }
      // Find the active terminal to ensure it's ready and not exited
      const activeTerm = openTerminals.find((t) => t.id === activeTerminalId); // Use raw state
      if (activeTerm?.isReady && activeTerm.exitCode === undefined) {
        // console.log(`TerminalContext: Resizing active terminal ID ${activeTerminalId} to ${cols}x${rows}`); // Verbose
        window.electronAPI.term_resize(activeTerminalId, { cols, rows });
      } else {
        console.warn(
          `TerminalContext: Cannot resize, active terminal ${activeTerminalId} not ready or has exited.`
        );
      }
    },
    [activeTerminalId, openTerminals]
  ); // Depends on activeId and the list

  // --- Global IPC Listener Setup (runs once) ---
  useEffect(() => {
    if (globalListenersAttached.current) {
      // console.log("TerminalContext: Global listeners already attached."); // DEBUG
      return;
    }

    console.log(
      "TerminalContext: Attaching global IPC listeners (term_onData, term_onExit, term_onError)..."
    );

    // Data received FROM main process for a specific terminal ID
    const handleData = (terminalId: string, data: string) => {
      // console.log(`TerminalContext: Routing data for ID ${terminalId}`); // Very Verbose
      const event = new CustomEvent<{ data: string }>(
        `terminal-data-${terminalId}`,
        { detail: { data } }
      );
      window.dispatchEvent(event);
    };
    const unsubscribeData = window.electronAPI.term_onData(handleData);

    // Exit signal FROM main process for a specific terminal ID
    const handleExit = (terminalId: string, code?: number) => {
      console.log(
        `TerminalContext: Received exit signal for ID ${terminalId}, code: ${code}`
      );
      const exitCodeToStore = typeof code === "number" ? code : null; // Treat undefined exit as null
      updateTerminalState(terminalId, {
        isLoading: false,
        isReady: false,
        exitCode: exitCodeToStore,
      });
      const event = new CustomEvent<{ code?: number | null }>(
        `terminal-exit-${terminalId}`,
        { detail: { code: exitCodeToStore } }
      );
      window.dispatchEvent(event);
    };
    const unsubscribeExit = window.electronAPI.term_onExit(handleExit);

    // Error signal FROM main process for a specific terminal ID
    const handleError = (terminalId: string, errorMessage: string) => {
      console.error(
        `TerminalContext: Received error signal for ID ${terminalId}: ${errorMessage}`
      );
      // Mark as not loading/ready and store the error
      updateTerminalState(terminalId, {
        isLoading: false,
        isReady: false,
        error: errorMessage,
      });
      const event = new CustomEvent<{ error: string }>(
        `terminal-error-${terminalId}`,
        { detail: { error: errorMessage } }
      );
      window.dispatchEvent(event);
    };
    const unsubscribeError = window.electronAPI.term_onError(handleError);

    globalListenersAttached.current = true;
    console.log("TerminalContext: Global listeners attached successfully.");

    // Cleanup global listeners on provider unmount
    return () => {
      console.log("TerminalContext: Cleaning up global IPC listeners...");
      unsubscribeData();
      unsubscribeExit();
      unsubscribeError();
      globalListenersAttached.current = false;
      console.log("TerminalContext: Global listeners cleaned up.");
    };
    // updateTerminalState is stable due to its definition with useCallback and empty deps array
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [updateTerminalState]); // Run only once on mount

  // --- NEW FUNCTION: Clear Active Terminal ---
  const clearActiveTerminal = useCallback(() => {
    if (!activeTerminalId) {
      console.warn("TerminalContext: Cannot clear, no active terminal.");
      return;
    }
    // Find the active terminal to ensure it's ready and not exited before sending clear event
    const activeTerm = openTerminals.find((t) => t.id === activeTerminalId);
    if (activeTerm?.isReady && activeTerm.exitCode === undefined) {
      console.log(
        `TerminalContext: Dispatching clear event for active terminal ID ${activeTerminalId}`
      );
      const event = new CustomEvent(`terminal-clear-${activeTerminalId}`);
      window.dispatchEvent(event);
    } else {
      console.warn(
        `TerminalContext: Cannot clear, active terminal ${activeTerminalId} not ready or has exited.`
      );
    }
  }, [activeTerminalId, openTerminals]); // Depends on activeId and the list

  // --- Context Value ---
  // Use useMemo to prevent unnecessary re-renders of consumers
  const contextValue = useMemo(
    () => ({
      openTerminals,
      activeTerminalId,
      createTerminal,
      closeTerminal,
      setActiveTerminal,
      writeToActiveTerminal,
      resizeActiveTerminal,
      clearActiveTerminal, // <<< ADDED HERE
      getActiveTerminal,
    }),
    [
      openTerminals,
      activeTerminalId,
      createTerminal,
      closeTerminal,
      setActiveTerminal,
      writeToActiveTerminal,
      resizeActiveTerminal,
      clearActiveTerminal, // <<< ADDED HERE
      getActiveTerminal,
    ]
  );

  return (
    <TerminalContext.Provider value={contextValue}>
      {children}
    </TerminalContext.Provider>
  );
};

// --- Hook to use the context ---
// Ensure this is exactly 'export const useTerminals'
export const useTerminals = (): TerminalContextProps => {
  const context = useContext(TerminalContext);
  if (context === undefined) {
    throw new Error("useTerminals must be used within a TerminalProvider");
  }
  return context;
};
// --- END FILE: src/renderer/contexts/TerminalContext.tsx ---
--- END FILE: src/renderer/contexts/TerminalContext.tsx ---

--- START FILE: src/renderer/contexts/EditorContext.tsx ---
// --- START FILE: src/renderer/contexts/EditorContext.tsx ---
import React, {
    createContext,
    useState,
    useContext,
    ReactNode,
    useCallback,
    useMemo,
} from 'react';
import path from 'path-browserify'; // Import path for basename in close confirmation

import type { ReadFileResponse, SaveFileResponse } from '../../shared.types';

// Define the structure for an open file
export interface OpenFile {
    path: string;
    content: string | null; // Content from last load/save
    isDirty: boolean;
    isLoading: boolean;
    error: string | null;
}

// Define the structure for cursor position
export interface CursorPosition {
    lineNumber: number;
    column: number;
}

interface EditorContextProps {
    openFiles: OpenFile[]; // Array of open files
    activeFilePath: string | null; // Path of the currently active file/tab
    cursorPosition: CursorPosition | null; // Track cursor position
    openOrFocusFile: (filePath: string) => Promise<void>; // Opens a new file or focuses existing tab
    closeFile: (filePath: string) => void; // Closes a tab/file
    setActiveFile: (filePath: string | null) => void; // Switches active tab
    updateActiveFileDirtyState: (currentEditorContent: string) => void; // Updates dirty flag ONLY for the active file
    saveActiveFile: (currentEditorContent: string) => Promise<void>; // Saves the currently active file's provided content
    getActiveFile: () => OpenFile | undefined; // Helper to get the active file object
    setCursorPosition: (position: CursorPosition | null) => void; // Setter for cursor position
}

const EditorContext = createContext<EditorContextProps | undefined>(undefined);

interface EditorProviderProps {
    children: ReactNode;
}

export const EditorProvider: React.FC<EditorProviderProps> = ({ children }) => {
    const [openFiles, setOpenFiles] = useState<OpenFile[]>([]);
    const [activeFilePath, setActiveFilePath] = useState<string | null>(null);
    const [cursorPosition, setCursorPosition] = useState<CursorPosition | null>(null);

    const getActiveFile = useCallback((): OpenFile | undefined => {
        return openFiles.find(f => f.path === activeFilePath);
    }, [openFiles, activeFilePath]);

    const setActiveFile = useCallback((filePath: string | null) => {
        if (filePath !== activeFilePath) {
            console.log(`EditorContext: Setting active file path to: ${filePath}`);
            setActiveFilePath(filePath);
            setCursorPosition(null);
        }
    }, [activeFilePath]);

    const openOrFocusFile = useCallback(async (filePath: string) => {
        console.log(`EditorContext: Request to open or focus file - ${filePath}`);
        const existingFile = openFiles.find(f => f.path === filePath);
        if (existingFile) {
            console.log(`EditorContext: File ${filePath} already open, focusing.`);
            setActiveFile(filePath);
            return;
        }
        console.log(`EditorContext: File ${filePath} not open, adding new entry and loading.`);
        const newFileEntry: OpenFile = { path: filePath, content: null, isDirty: false, isLoading: true, error: null };
        setOpenFiles(prevFiles => [...prevFiles, newFileEntry]);
        setActiveFile(filePath);
        try {
            const response: ReadFileResponse = await window.electronAPI.fs_readFile(filePath);
            if (response.success) {
                console.log(`EditorContext: File loaded successfully - ${filePath}`);
                setOpenFiles(currentFiles => {
                     const updatedFiles = currentFiles.map(file =>
                        file.path === filePath
                            ? { ...file, content: response.content, isLoading: false, error: null, isDirty: false }
                            : file
                     );
                     console.log(`[EditorContext -> openOrFocusFile -> success] State update executed for ${filePath}. isLoading should be false.`);
                     return updatedFiles;
                 });
            } else {
                console.error(`EditorContext: Failed to read file ${filePath}:`, response.error);
                 setOpenFiles(currentFiles => currentFiles.map(file =>
                    file.path === filePath
                        ? { ...file, content: `// Error: ${response.error}`, isLoading: false, error: `Load Error: ${response.error}`, isDirty: false }
                        : file
                 ));
            }
        } catch (err) {
            const errorMsg = err instanceof Error ? err.message : String(err);
            console.error(`EditorContext: IPC Error reading file ${filePath}:`, errorMsg);
             setOpenFiles(currentFiles => currentFiles.map(file =>
                file.path === filePath
                    ? { ...file, content: `// IPC Error: ${errorMsg}`, isLoading: false, error: `IPC Error: ${errorMsg}`, isDirty: false }
                    : file
             ));
        }
    }, [openFiles, activeFilePath, setActiveFile]);

    const closeFile = useCallback((filePath: string) => {
        console.log(`EditorContext: Request to close file - ${filePath}`);
        const currentOpenFiles = openFiles;
        const fileToClose = currentOpenFiles.find(f => f.path === filePath);
        const fileToCloseIndex = currentOpenFiles.findIndex(f => f.path === filePath);
        if (!fileToClose) return;
        if (fileToClose.isDirty) {
             const confirmClose = window.confirm(`File "${path.basename(fileToClose.path)}" has unsaved changes. Close anyway?`);
             if (!confirmClose) {
                 console.log(`EditorContext: Close cancelled for dirty file ${filePath}.`);
                 return;
             }
             console.warn(`EditorContext: Closing dirty file ${filePath} without saving.`);
        }
        const remainingFiles = currentOpenFiles.filter(f => f.path !== filePath);
        setOpenFiles(remainingFiles);
        if (activeFilePath === filePath) {
            let nextActivePath: string | null = null;
            if (remainingFiles.length > 0) {
                const nextIndex = Math.min(remainingFiles.length - 1, Math.max(0, fileToCloseIndex -1));
                 nextActivePath = remainingFiles[nextIndex]?.path || null;
            }
            setActiveFile(nextActivePath);
        }
    }, [openFiles, activeFilePath, setActiveFile]);

    const updateActiveFileDirtyState = useCallback((currentEditorContent: string) => {
        const currentActivePath = activeFilePath;
        if (!currentActivePath) return;
        setOpenFiles(currentFiles => {
            const activeFileIndex = currentFiles.findIndex(f => f.path === currentActivePath);
            if (activeFileIndex === -1) {
                 console.warn(`[updateActiveFileDirtyState] Active file path ${currentActivePath} not found in state.`);
                 return currentFiles;
            }
            const activeFile = currentFiles[activeFileIndex];
            if (activeFile.content === null || activeFile.isLoading) {
                 console.log(`[updateActiveFileDirtyState] Skipping dirty check for ${currentActivePath}, content not loaded or is loading.`);
                 return currentFiles;
            }
            const shouldBeDirty = currentEditorContent !== activeFile.content;
            console.log(`[updateActiveFileDirtyState] Comparing for ${currentActivePath}: Editor content (len ${currentEditorContent.length}) !== Context content (len ${activeFile.content.length})? Result: ${shouldBeDirty}. Current state isDirty: ${activeFile.isDirty}`);
            if (activeFile.isDirty !== shouldBeDirty) {
                console.log(`[updateActiveFileDirtyState] *** State Change Needed *** Setting dirty state for ${currentActivePath} to ${shouldBeDirty}`);
                return currentFiles.map((file, index) =>
                    index === activeFileIndex ? { ...file, isDirty: shouldBeDirty } : file
                );
            }
            return currentFiles;
        });
    }, [activeFilePath]);

    // *** MODIFIED saveActiveFile ***
    const saveActiveFile = useCallback(async (currentEditorContent: string) => {
        const currentActiveFilePath = activeFilePath;
        const currentOpenFiles = openFiles;

        const activeFile = currentOpenFiles.find(f => f.path === currentActiveFilePath);

        console.log(`[EditorContext -> saveActiveFile] Called for path: ${activeFile?.path}.`);
        console.log(`[EditorContext -> saveActiveFile] Content passed from EditorPanel (length: ${currentEditorContent?.length}):`, currentEditorContent?.substring(0, 50) + '...');

        // *** SIMPLIFIED CHECK: Only ensure we found *an* active file object ***
        if (!activeFile) {
            console.warn(`EditorContext [saveActiveFile]: Cannot save. No active file object found for path: ${currentActiveFilePath}.`);
            // Maybe set a general error? This case shouldn't happen if activeFilePath is valid.
            return;
        }

        // *** Log the state we *do* have, even if we don't block on it anymore ***
        console.log(`[EditorContext -> saveActiveFile] State of active file (${activeFile.path}) at save time: isLoading=${activeFile.isLoading}, contentIsNull=${activeFile.content === null}, isDirty=${activeFile.isDirty}`);

        // Check if save is needed (content changed or already dirty)
        // We still need activeFile.content for this comparison, but if it's null, the comparison will likely proceed (which is okay)
        // Let's add a specific log for this check
        const isContentSame = activeFile.content !== null && currentEditorContent === activeFile.content;
        console.log(`[EditorContext -> saveActiveFile] Checking if save needed: isContentSame=${isContentSame}, isDirty=${activeFile.isDirty}`);
        if (isContentSame && !activeFile.isDirty) {
             console.log(`EditorContext [saveActiveFile]: Content for ${activeFile.path} has not changed and not dirty. Skipping save.`);
             return;
        }

        console.log(`EditorContext [saveActiveFile]: Request to save file - ${activeFile.path}`);
        const targetPath = activeFile.path;
        // Mark as loading
        setOpenFiles(files => files.map(f => f.path === targetPath ? { ...f, isLoading: true, error: null } : f));

        try {
            console.log(`EditorContext [saveActiveFile]: Calling window.electronAPI.fs_saveFile for ${targetPath}...`);
            const response: SaveFileResponse = await window.electronAPI.fs_saveFile(targetPath, currentEditorContent);

            console.log(`[EditorContext -> saveActiveFile] IPC Response for ${targetPath}:`, response);

            if (response.success) {
                console.log(`EditorContext [saveActiveFile]: File saved successfully via IPC - ${targetPath}`);
                console.log(`[EditorContext -> saveActiveFile] Updating context state: isDirty=false, content=currentEditorContent`);
                setOpenFiles(files => files.map(f => f.path === targetPath ? {
                    ...f,
                    content: currentEditorContent,
                    isDirty: false,
                    isLoading: false,
                    error: null
                 } : f));
            } else {
                console.error(`EditorContext [saveActiveFile]: Failed to save file ${targetPath} (IPC Response):`, response.error);
                console.log(`[EditorContext -> saveActiveFile] Updating context state: isLoading=false, error=${response.error}`);
                setOpenFiles(files => files.map(f => f.path === targetPath ? {
                    ...f,
                    isLoading: false, // Still set isLoading false even on error
                    error: `Save Error: ${response.error || 'Unknown error'}`
                 } : f));
            }
        } catch (err) {
            const errorMsg = err instanceof Error ? err.message : String(err);
            console.error(`EditorContext [saveActiveFile]: IPC Error saving file ${targetPath}:`, errorMsg);
            console.log(`[EditorContext -> saveActiveFile] Updating context state after IPC error: isLoading=false, error=${errorMsg}`);
             setOpenFiles(files => files.map(f => f.path === targetPath ? {
                    ...f,
                    isLoading: false, // Still set isLoading false even on error
                    error: `IPC Save Error: ${errorMsg}`
             } : f));
        }
    }, [openFiles, activeFilePath]); // Keep dependencies


    // --- Context Value ---
    const contextValue = useMemo(() => ({
        openFiles,
        activeFilePath,
        cursorPosition,
        openOrFocusFile,
        closeFile,
        setActiveFile,
        updateActiveFileDirtyState,
        saveActiveFile,
        getActiveFile,
        setCursorPosition,
    }), [
        openFiles, activeFilePath, cursorPosition, openOrFocusFile, closeFile, setActiveFile,
        updateActiveFileDirtyState, saveActiveFile, getActiveFile, setCursorPosition
    ]);

    return (
        <EditorContext.Provider value={contextValue}>
            {children}
        </EditorContext.Provider>
    );
};

// --- Hook to use the context ---
export const useEditor = (): EditorContextProps => {
    const context = useContext(EditorContext);
    if (context === undefined) {
        throw new Error('useEditor must be used within an EditorProvider');
    }
    return context;
};
// --- END FILE: src/renderer/contexts/EditorContext.tsx ---
--- END FILE: src/renderer/contexts/EditorContext.tsx ---

--- START FILE: src/renderer/contexts/ThemeContext.tsx ---
// --- START FILE: src/renderer/contexts/ThemeContext.tsx ---
// src/renderer/contexts/ThemeContext.tsx
import React, {
    createContext,
    useState,
    useContext,
    useEffect,
    ReactNode,
    useMemo,
  } from "react";
  
  // Add the new theme names here
  export type ThemeName =
    | "light"
    | "dark"
    | "win95"
    | "pipboy"
    | "mirc"
    | "qbasic"
    | "orange"
    | "cga"
    | "atari"
    | "snes"
    | "bw_tv";
  
  // Define base font sizes (can be adjusted)
  const BASE_FONT_SIZES = {
    ui: 14,
    editor: 12,
    terminal: 12,
  };
  
  // Define the shape of the context value
  interface ThemeContextProps {
    theme: ThemeName;
    setTheme: (theme: ThemeName) => void;
    fontSizeModifier: number; // e.g., -2, -1, 0, 1, 2 steps
    increaseFontSize: () => void;
    decreaseFontSize: () => void;
    resetFontSize: () => void;
  }
  
  const ThemeContext = createContext<ThemeContextProps | undefined>(undefined);
  
  interface ThemeProviderProps {
    children: ReactNode;
    defaultTheme?: ThemeName;
    defaultFontSizeModifier?: number;
  }
  
  const ALL_THEME_CLASSES = [ // Keep this potentially updated for cleanup, though dynamic removal works
    "theme-light",
    "theme-dark",
    "theme-win95",
    "theme-pipboy",
    "theme-mirc",
    "theme-qbasic",
    "theme-orange",
    "theme-cga",
    "theme-atari",
    "theme-snes",
    "theme-bw_tv",
  ];
  const FONT_SIZE_STEP = 1; // How many pixels each step changes
  const MAX_FONT_MODIFIER = 4; // Limit how large text can get
  const MIN_FONT_MODIFIER = -2; // Limit how small text can get
  
  export const ThemeProvider: React.FC<ThemeProviderProps> = ({
    children,
    defaultTheme = "dark",
    defaultFontSizeModifier = 0,
  }) => {
    const [theme, setTheme] = useState<ThemeName>(defaultTheme);
    const [fontSizeModifier, setFontSizeModifier] = useState<number>(
      defaultFontSizeModifier
    );
  
    // Apply Theme Class
    useEffect(() => {
      const rootElement = document.getElementById("root");
      if (rootElement) {
          // Remove all known theme classes before adding the new one
          const classesToRemove = ALL_THEME_CLASSES.filter(cls => rootElement.classList.contains(cls));
          if (classesToRemove.length > 0) {
              rootElement.classList.remove(...classesToRemove);
              document.body.classList.remove(...classesToRemove); // Also remove from body
          }
          // Add the current theme class
          rootElement.classList.add(`theme-${theme}`);
          document.body.classList.add(`theme-${theme}`); // Also apply to body
          console.log(`Theme applied: theme-${theme}`);
      }
  }, [theme]);
  
  
    // Apply Font Size CSS Variables
    useEffect(() => {
      const rootStyle = document.documentElement.style;
      const modifier = fontSizeModifier * FONT_SIZE_STEP;
  
      const uiSize = BASE_FONT_SIZES.ui + modifier;
      const editorSize = BASE_FONT_SIZES.editor + modifier;
      const terminalSize = BASE_FONT_SIZES.terminal + modifier;
  
      rootStyle.setProperty("--font-size-base", `${uiSize}px`);
      rootStyle.setProperty("--font-size-editor", `${editorSize}px`);
      rootStyle.setProperty("--font-size-terminal", `${terminalSize}px`);
  
      console.log(
        `Font sizes updated: Base=${uiSize}px, Editor=${editorSize}px, Terminal=${terminalSize}px`
      );
  
      // Trigger resize/reflow for editor/terminal if needed (optional)
      // This helps Monaco/Xterm recalculate layout with new font size
      window.dispatchEvent(new Event("resize"));
    }, [fontSizeModifier]);
  
    // Font size control functions
    const increaseFontSize = () => {
      setFontSizeModifier((prev) => Math.min(prev + 1, MAX_FONT_MODIFIER));
    };
    const decreaseFontSize = () => {
      setFontSizeModifier((prev) => Math.max(prev - 1, MIN_FONT_MODIFIER));
    };
    const resetFontSize = () => {
      setFontSizeModifier(0);
    };
  
    const contextValue = useMemo(
      () => ({
        theme,
        setTheme,
        fontSizeModifier,
        increaseFontSize,
        decreaseFontSize,
        resetFontSize,
      }),
      [theme, fontSizeModifier]
    ); // Include modifier in dependencies
  
    return (
      <ThemeContext.Provider value={contextValue}>
        {children}
      </ThemeContext.Provider>
    );
  };
  
  export const useTheme = (): ThemeContextProps => {
    // Rename to useSettings or similar later maybe
    const context = useContext(ThemeContext);
    if (context === undefined) {
      throw new Error("useTheme must be used within a ThemeProvider");
    }
    return context;
  };
  // --- END FILE: src/renderer/contexts/ThemeContext.tsx ---
--- END FILE: src/renderer/contexts/ThemeContext.tsx ---

--- START FILE: src/renderer/App.tsx ---
// --- START FILE: src/renderer/App.tsx ---
// src/renderer/App.tsx
import React, { useEffect, useState, useCallback } from 'react'; // <<< Import useState, useCallback
import { Allotment } from 'allotment';
import 'allotment/dist/style.css';
import Sidebar from './components/Sidebar';
import MainPanel from './components/MainPanel';
import StatusBar from './components/StatusBar';
import CommandPalette from './components/CommandPalette'; // <<< NEW: Import CommandPalette
import './App.css';

// Helper function to get initial sidebar width from CSS variable
const getSidebarInitialSize = (): number => {
  if (typeof document === 'undefined') return 150;
  try {
      const widthValue = getComputedStyle(document.documentElement)
                           .getPropertyValue('--sidebar-width')?.trim() || '150px';
      return parseInt(widthValue.replace('px', ''), 10) || 150;
  } catch (e) {
      console.warn("Could not get computed style for sidebar width, using default.", e);
      return 150;
  }
};


function App() {
  const [isCommandPaletteOpen, setIsCommandPaletteOpen] = useState(false); // <<< NEW: State for palette

  const toggleCommandPalette = useCallback(() => {
    setIsCommandPaletteOpen(prev => !prev);
  }, []);

  // Effect for keyboard shortcuts
  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      const ctrlAlt = event.ctrlKey && event.altKey;
      const ctrlShift = event.ctrlKey && event.shiftKey; // <<< NEW: For palette shortcut
      const metaShift = event.metaKey && event.shiftKey; // <<< NEW: For Mac palette shortcut

      if (ctrlAlt && event.key.toLowerCase() === 'q') {
        console.log("Renderer: Ctrl+Alt+Q detected, requesting app quit.");
        event.preventDefault();
        window.electronAPI.app_quit();
      } else if (ctrlAlt && event.key.toLowerCase() === 'f') {
        console.log("Renderer: Ctrl+Alt+F detected, requesting fullscreen toggle.");
        event.preventDefault();
        window.electronAPI.window_toggleFullscreen();
      } else if (ctrlAlt && event.key.toLowerCase() === 'i') {
         console.log("Renderer: Ctrl+Alt+I detected, requesting devtools toggle.");
         event.preventDefault();
         window.electronAPI.window_toggleDevTools();
      } else if ((ctrlShift || metaShift) && event.key.toLowerCase() === 'p') { // <<< NEW: Palette shortcut
          console.log("Renderer: Ctrl/Cmd+Shift+P detected, toggling command palette.");
          event.preventDefault();
          toggleCommandPalette(); // <<< NEW: Call toggle function
      }
    };

    console.log("Adding global keyboard shortcuts listener (including Cmd/Ctrl+Shift+P)."); // Updated log
    window.addEventListener('keydown', handleKeyDown);

    return () => {
      console.log("Removing global keyboard shortcuts listener.");
      window.removeEventListener('keydown', handleKeyDown);
    };
  }, [toggleCommandPalette]); // <<< NEW: Add toggleCommandPalette dependency

  return (
    <div className="app-container">
      {/* Main content area (Allotment for Sidebar/MainPanel split) */}
      <div className="main-content-area">
        <Allotment>
          <Allotment.Pane
            preferredSize={getSidebarInitialSize()}
            minSize={150}
            maxSize={500}
            snap
          >
            <Sidebar />
          </Allotment.Pane>

          <Allotment.Pane minSize={300} >
            <MainPanel />
          </Allotment.Pane>
        </Allotment>
      </div>

      {/* Status Bar rendered below the main content area */}
      <StatusBar />

      {/* Command Palette rendered conditionally as an overlay */}
      <CommandPalette
        isOpen={isCommandPaletteOpen}
        onClose={() => setIsCommandPaletteOpen(false)}
      />
    </div>
  );
}

export default App;
// --- END FILE: src/renderer/App.tsx ---
--- END FILE: src/renderer/App.tsx ---

--- START FILE: src/renderer/vite-env.d.ts ---
// src/renderer/vite-env.d.ts
/// <reference types="vite/client" />

// Import the interface shape from the preload script
import type { ElectronAPI } from '@preload/index'; // Path alias should work

// Extend the global Window interface
declare global {
  interface Window {
    // Ensure this declaration EXACTLY matches the exported interface from preload
    electronAPI: ElectronAPI;
  }
}

// Make this file a module by exporting an empty object if it doesn't export anything else
// This helps prevent potential issues with global scope pollution in TypeScript.
export {};
--- END FILE: src/renderer/vite-env.d.ts ---

--- START FILE: src/renderer/main.tsx ---
// --- START FILE: src/renderer/main.tsx ---
// src/renderer/main.tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import { ThemeProvider } from './contexts/ThemeContext'; // Import the ThemeProvider
import { EditorProvider } from './contexts/EditorContext'; // Import the EditorProvider
import { TerminalProvider } from './contexts/TerminalContext'; // Import the TerminalProvider
import './index.css'; // Ensure base styles are imported
import 'allotment/dist/style.css';
// Import UUID library where needed (e.g., in TerminalContext), no need to assign to globalThis here.
// import { v4 as uuidv4 } from 'uuid'; // No longer needed here


const rootElement = document.getElementById('root');
if (!rootElement) throw new Error('Failed to find the root element');

const root = ReactDOM.createRoot(rootElement);
root.render(
  // Wrap ALL providers around App
  // Order might matter if one context depends on another, but here it likely doesn't.
  <ThemeProvider defaultTheme="orange">
    <EditorProvider>
      <TerminalProvider> {/* Add TerminalProvider */}
        <App />
      </TerminalProvider>
    </EditorProvider>
  </ThemeProvider>
);
// --- END FILE: src/renderer/main.tsx ---
--- END FILE: src/renderer/main.tsx ---

--- START FILE: src/renderer/index.css ---
/* --- START FILE: src/renderer/index.css --- */
/* src/renderer/index.css */

/* --- FONT FACE DEFINITIONS (PLACEHOLDERS) --- */
/* Example for Pip-Boy style font */
/* @font-face {
  font-family: 'Overseer';
  src: url('/fonts/overseer-webfont.woff2') format('woff2'),
       url('/fonts/overseer-webfont.woff') format('woff');
  font-weight: normal;
  font-style: normal;
} */

/* Example for classic Windows font (use system fonts if available) */
/* @font-face {
  font-family: 'MS Sans Serif';
  src: local('Microsoft Sans Serif'), local('MS Sans Serif'); // Try local first
  // Add web font source if hosting it
  // src: url('/fonts/microsoft-sans-serif.woff2') format('woff2');
} */

/* --- END FONT FACE DEFINITIONS --- */


/* Define CSS Variables for the default theme (Light) */
:root {
  /* Font */
  --font-family-ui: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  --font-family-mono: Consolas, 'Courier New', monospace; /* More common monospace */
  --font-size-base: 14px;
  --font-size-sm: 0.875rem; /* 12px */
  --font-size-md: 1rem;    /* 14px */
  --font-size-lg: 1.125rem; /* 16px */
  --font-size-xl: 1.25rem;  /* 18px */
  --font-size-editor: var(--font-size-sm); /* Default editor size */
  --font-size-terminal: var(--font-size-sm); /* Default terminal size */

  /* Colors - Light Theme */
  --color-bg-app: #f8f8f8;
  --color-bg-sidebar: #ececec;
  --color-bg-main: #ffffff;
  --color-bg-editor: #ffffff; /* Monaco default light */
  --color-bg-terminal: #ffffff; /* Terminal default light */
  --color-bg-button: #e0e0e0;
  --color-bg-button-hover: #d6d6d6;
  --color-bg-button-active: #cccccc;
  --color-bg-input: #ffffff;
  --color-bg-dropdown: #ffffff;
  --color-bg-selected: #d5e5f6; /* A light blue for selections */
  --color-bg-hover: #ededed; /* General hover background */

  --color-text-primary: #1f1f1f;
  --color-text-secondary: #555555;
  --color-text-tertiary: #888888; /* For less important info */
  --color-text-terminal: #333333; /* Terminal default light */
  --color-text-heading: #000000;
  --color-text-button: #1f1f1f;
  --color-text-link: #0066cc;
  --color-text-link-hover: #004c99;
  --color-text-placeholder: #aaaaaa;
  --color-text-inverse: #ffffff; /* Text on dark backgrounds */
  --color-text-accent: #007acc; /* Accent color, e.g., focus ring */
  --color-text-error: #d9534f;

  --color-border: #cccccc;
  --color-border-accent: #aaaaaa;
  --color-border-input: #b0b0b0;
  --color-border-focus: #007acc; /* Use accent for focus */

  /* Spacing */
  --spacing-xxs: 2px;
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;

  /* Borders & Shadows */
  --border-radius-sm: 3px;
  --border-radius-md: 5px;
  --box-shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);
  --box-shadow-md: 0 3px 6px rgba(0, 0, 0, 0.15);
  --border-standard: 1px solid var(--color-border);
  --border-accent: 1px solid var(--color-border-accent);
  --border-button: 1px solid var(--color-border-input);
  --button-bevel-shadow: none; /* For aesthetic themes */

  /* Other UI Elements */
  --scrollbar-thumb-bg: #c1c1c1;
  --scrollbar-track-bg: #f1f1f1;

  /* Specific Component Variables (Examples) */
  --sidebar-width: 150px; /* <<< ADJUSTED DEFAULT WIDTH <<< */
  --terminal-height: 200px;

  /* Theme Specific Overrides (Placeholders) */
  --scanline-opacity: 0;
  --crt-filter: none;
  --noise-opacity: 0;
  --win95-bevel-shadow-light: transparent;
  --win95-bevel-shadow-lighter: transparent;
  --win95-bevel-shadow-dark: transparent;
  --win95-bevel-shadow-darker: transparent;
}

/* Dark Theme */
.theme-dark {
  /* (Keep dark theme variables as before) */
  --font-family-ui: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
  --font-family-mono: Consolas, 'Courier New', monospace;

  --color-bg-app: #1e1e1e;
  --color-bg-sidebar: #252526;
  --color-bg-main: #1e1e1e;
  --color-bg-editor: #1e1e1e;
  --color-bg-terminal: #1e1e1e;
  --color-bg-button: #3a3a3a;
  --color-bg-button-hover: #4a4a4a;
  --color-bg-button-active: #5a5a5a;
  --color-bg-input: #3c3c3c;
  --color-bg-dropdown: #3c3c3c;
  --color-bg-selected: #094771;
  --color-bg-hover: #2a2d2e;

  --color-text-primary: #d4d4d4;
  --color-text-secondary: #cccccc;
  --color-text-tertiary: #a0a0a0;
  --color-text-terminal: #cccccc;
  --color-text-heading: #ffffff;
  --color-text-button: #d4d4d4;
  --color-text-link: #3794ff;
  --color-text-link-hover: #60aaff;
  --color-text-placeholder: #777777;
  --color-text-inverse: #1f1f1f;
  --color-text-accent: #007acc;
  --color-text-error: #f48771;

  --color-border: #3f3f46;
  --color-border-accent: #505050;
  --color-border-input: #5f5f5f;
  --color-border-focus: #007acc;

  --scrollbar-thumb-bg: #555;
  --scrollbar-track-bg: #333;

  --border-standard: 1px solid var(--color-border);
  --border-accent: 1px solid var(--color-border-accent);
  --border-button: 1px solid var(--color-border-input);
  --button-bevel-shadow: none;
}

/* Windows 95 Theme - Enhanced */
.theme-win95 {
  --font-family-ui: Tahoma, 'MS Sans Serif', 'Microsoft Sans Serif', system-ui, sans-serif; /* Prioritize classic fonts */
  --font-family-mono: 'Courier New', monospace;
  --font-size-base: 13px;
  --font-size-editor: 12px;
  --font-size-terminal: 12px;

  --color-bg-app: #c0c0c0;
  --color-bg-sidebar: #c0c0c0;
  --color-bg-main: #ffffff;
  --color-bg-editor: #ffffff;
  --color-bg-terminal: #000080; /* Classic blue console */
  --color-bg-button: #c0c0c0;
  --color-bg-button-hover: #c0c0c0;
  --color-bg-button-active: #b0b0b0; /* Slightly darker pressed */
  --color-bg-input: #ffffff;
  --color-bg-dropdown: #ffffff;
  --color-bg-selected: #000080;
  --color-bg-hover: #c0c0c0;

  --color-text-primary: #000000;
  --color-text-secondary: #000000;
  --color-text-tertiary: #808080;
  --color-text-terminal: #c0c0c0;
  --color-text-heading: #000000;
  --color-text-button: #000000;
  --color-text-link: #0000ff;
  --color-text-link-hover: #0000ff;
  --color-text-placeholder: #808080;
  --color-text-inverse: #ffffff; /* Text on selection bg */
  --color-text-accent: #000080;
  --color-text-error: #ff0000;

  --color-border: #808080;       /* Inner bevel dark gray */
  --color-border-accent: #ffffff; /* Outer bevel white */
  --color-border-dark: #000000;   /* Inner bevel black */
  --color-border-light: #dfdfdf; /* Outer bevel light gray */
  --color-border-input: #808080;
  --color-border-focus: #000000;

  --scrollbar-thumb-bg: #c0c0c0;
  --scrollbar-track-bg: #a0a0a0; /* Needs bevel styles */

  --border-standard: 1px solid var(--color-border); /* Use specific borders below */
  --border-radius-sm: 0; /* No rounded corners */
  --border-radius-md: 0;
  --box-shadow-sm: none;
  --box-shadow-md: none;

  /* Bevel for buttons etc. - Use direct styles instead */
  --button-bevel-shadow: none; /* Will apply via direct CSS */

  /* Specific Bevel Colors */
  --win95-bevel-shadow-light: #ffffff;
  --win95-bevel-shadow-lighter: #dfdfdf;
  --win95-bevel-shadow-dark: #808080;
  --win95-bevel-shadow-darker: #0a0a0a;
}

/* Pip-Boy Theme */
.theme-pipboy {
  /* Assumes 'Overseer' font is loaded or replace with monospace */
  --font-family-ui: 'Overseer', Consolas, monospace;
  --font-family-mono: 'Overseer', Consolas, monospace;
  --font-size-base: 15px; /* Slightly larger, adjust as needed */
  --font-size-editor: 14px;
  --font-size-terminal: 14px;

  /* Pip-Boy Green */
  --pipboy-green: #15ff60;
  --pipboy-green-dark: #10b445;
  --pipboy-green-darker: #0a702a;
  --pipboy-bg: #0a1a0f; /* Very dark green/black */
  --pipboy-bg-lighter: #102a18;

  --color-bg-app: var(--pipboy-bg);
  --color-bg-sidebar: var(--pipboy-bg-lighter);
  --color-bg-main: var(--pipboy-bg);
  --color-bg-editor: var(--pipboy-bg);
  --color-bg-terminal: var(--pipboy-bg);
  --color-bg-button: transparent;
  --color-bg-button-hover: var(--pipboy-green-darker);
  --color-bg-button-active: var(--pipboy-green-dark);
  --color-bg-input: var(--pipboy-bg-lighter);
  --color-bg-dropdown: var(--pipboy-bg-lighter);
  --color-bg-selected: var(--pipboy-green-dark);
  --color-bg-hover: var(--pipboy-green-darker);

  --color-text-primary: var(--pipboy-green);
  --color-text-secondary: color-mix(in srgb, var(--pipboy-green) 70%, black);
  --color-text-tertiary: color-mix(in srgb, var(--pipboy-green) 50%, black);
  --color-text-terminal: var(--pipboy-green);
  --color-text-heading: var(--pipboy-green);
  --color-text-button: var(--pipboy-green);
  --color-text-link: var(--pipboy-green);
  --color-text-link-hover: color-mix(in srgb, var(--pipboy-green) 80%, white);
  --color-text-placeholder: var(--color-text-tertiary);
  --color-text-inverse: var(--pipboy-bg); /* Text on selection bg */
  --color-text-accent: var(--pipboy-green);
  --color-text-error: #ff5555; /* A contrasting red/orange */

  --color-border: var(--pipboy-green-dark);
  --color-border-accent: var(--pipboy-green);
  --color-border-input: var(--pipboy-green-dark);
  --color-border-focus: var(--pipboy-green);

  --scrollbar-thumb-bg: var(--pipboy-green-dark);
  --scrollbar-track-bg: var(--pipboy-bg-lighter);

  --border-standard: 1px solid var(--color-border);
  --border-accent: 1px solid var(--color-border-accent);
  --border-button: 1px solid var(--color-border);
  --border-radius-sm: 0;
  --border-radius-md: 0;
  --box-shadow-sm: none;
  --box-shadow-md: none;
  --button-bevel-shadow: none;

  /* Effects */
  --scanline-opacity: 0.15; /* Adjust opacity */
  --crt-filter: brightness(1.1) contrast(1.1); /* Basic CRT effect */
}

/* mIRC Inspired Theme (Refined) */
.theme-mirc {
  /* Classic Windows fonts */
  --font-family-ui: 'MS Sans Serif', Tahoma, system-ui, sans-serif;
  --font-family-mono: 'Courier New', monospace;
  --font-size-base: 13px;
  --font-size-editor: 12px;
  --font-size-terminal: 12px;

  /* mIRC often used system colors, very similar to Win95 */
  --color-bg-app: #c0c0c0;
  --color-bg-sidebar: #c0c0c0; /* Channel list area */
  --color-bg-main: #ffffff; /* Main chat/edit area */
  --color-bg-editor: #ffffff;
  --color-bg-terminal: #000000; /* Black usually for status/raw */
  --color-bg-button: #c0c0c0;
  --color-bg-button-hover: #c0c0c0;
  --color-bg-button-active: #b0b0b0;
  --color-bg-input: #ffffff; /* Input line */
  --color-bg-dropdown: #ffffff;
  --color-bg-selected: #000080;
  --color-bg-hover: #c0c0c0;

  --color-text-primary: #000000;
  --color-text-secondary: #000080; /* Often blue for links/commands */
  --color-text-tertiary: #808080;
  --color-text-terminal: #00ff00; /* Green text on black */
  --color-text-heading: #000000;
  --color-text-button: #000000;
  --color-text-link: #0000ff;
  --color-text-link-hover: #ff0000; /* Often red hover */
  --color-text-placeholder: #808080;
  --color-text-inverse: #ffffff;
  --color-text-accent: #000080;
  --color-text-error: #ff0000;

  --color-border: #808080;
  --color-border-accent: #ffffff;
  --color-border-input: #808080;
  --color-border-focus: #000000;
  --color-border-dark: #000000;
  --color-border-light: #dfdfdf;

  --scrollbar-thumb-bg: #c0c0c0;
  --scrollbar-track-bg: #a0a0a0;

  --border-standard: 1px solid var(--color-border);
  --border-radius-sm: 0;
  --border-radius-md: 0;
  --box-shadow-sm: none;
  --box-shadow-md: none;
  --button-bevel-shadow: none; /* Use direct styles */

  --win95-bevel-shadow-light: #ffffff;
  --win95-bevel-shadow-lighter: #dfdfdf;
  --win95-bevel-shadow-dark: #808080;
  --win95-bevel-shadow-darker: #0a0a0a;
}


/* QBasic Theme */
.theme-qbasic {
  --font-family-ui: 'Courier New', monospace;
  --font-family-mono: 'Courier New', monospace;
  --font-size-base: 14px;
  --font-size-editor: 13px;
  --font-size-terminal: 13px;

  --qbasic-blue: #0000AA;
  --qbasic-white: #FFFFFF;
  --qbasic-yellow: #FFFF55;
  --qbasic-gray: #AAAAAA;
  --qbasic-dark-gray: #555555;

  --color-bg-app: var(--qbasic-blue);
  --color-bg-sidebar: var(--qbasic-dark-gray);
  --color-bg-main: var(--qbasic-blue);
  --color-bg-editor: var(--qbasic-blue);
  --color-bg-terminal: var(--qbasic-blue);
  --color-bg-button: var(--qbasic-gray);
  --color-bg-button-hover: #bbbbbb;
  --color-bg-button-active: #cccccc;
  --color-bg-input: var(--qbasic-dark-gray);
  --color-bg-dropdown: var(--qbasic-gray);
  --color-bg-selected: var(--qbasic-dark-gray);
  --color-bg-hover: #bbbbbb;

  --color-text-primary: var(--qbasic-yellow); /* Bright text */
  --color-text-secondary: var(--qbasic-white);
  --color-text-tertiary: var(--qbasic-gray);
  --color-text-terminal: var(--qbasic-yellow);
  --color-text-heading: var(--qbasic-white);
  --color-text-button: #000000; /* Black text on gray button */
  --color-text-link: var(--qbasic-yellow);
  --color-text-link-hover: var(--qbasic-white);
  --color-text-placeholder: var(--qbasic-gray);
  --color-text-inverse: var(--qbasic-white); /* Text on selection */
  --color-text-accent: var(--qbasic-yellow);
  --color-text-error: #FF5555;

  --color-border: var(--qbasic-gray);
  --color-border-accent: var(--qbasic-white);
  --color-border-input: var(--qbasic-gray);
  --color-border-focus: var(--qbasic-yellow);

  --scrollbar-thumb-bg: var(--qbasic-gray);
  --scrollbar-track-bg: var(--qbasic-dark-gray);

  --border-standard: 1px solid var(--color-border);
  --border-accent: 1px solid var(--color-border-accent);
  --border-button: 1px solid var(--color-border);
  --border-radius-sm: 0;
  --border-radius-md: 0;
  --box-shadow-sm: none;
  --box-shadow-md: none;
  --button-bevel-shadow: none;
}

/* Orange Monochrome Theme */
.theme-orange {
  --font-family-ui: 'Courier New', monospace;
  --font-family-mono: 'Courier New', monospace;
  --font-size-base: 14px;
  --font-size-editor: 13px;
  --font-size-terminal: 13px;

  --orange-bright: #FFA500; /* Bright Orange */
  --orange-medium: #D98C00; /* Slightly darker orange for borders/accents */
  --orange-dark: #201500; /* Very dark brown/black background */
  --orange-darker: #100A00;

  --color-bg-app: var(--orange-dark);
  --color-bg-sidebar: var(--orange-darker);
  --color-bg-main: var(--orange-dark);
  --color-bg-editor: var(--orange-dark);
  --color-bg-terminal: var(--orange-dark);
  --color-bg-button: transparent;
  --color-bg-button-hover: var(--orange-medium);
  --color-bg-button-active: var(--orange-bright);
  --color-bg-input: var(--orange-darker);
  --color-bg-dropdown: var(--orange-darker);
  --color-bg-selected: var(--orange-medium);
  --color-bg-hover: var(--orange-medium);

  --color-text-primary: var(--orange-bright);
  --color-text-secondary: color-mix(in srgb, var(--orange-bright) 70%, black);
  --color-text-tertiary: color-mix(in srgb, var(--orange-bright) 50%, black);
  --color-text-terminal: var(--orange-bright);
  --color-text-heading: var(--orange-bright);
  --color-text-button: var(--orange-bright);
  --color-text-link: var(--orange-bright);
  --color-text-link-hover: color-mix(in srgb, var(--orange-bright) 80%, white);
  --color-text-placeholder: var(--color-text-tertiary);
  --color-text-inverse: var(--orange-dark); /* Text on selection bg */
  --color-text-accent: var(--orange-bright);
  --color-text-error: #FF5555;

  --color-border: var(--orange-medium);
  --color-border-accent: var(--orange-bright);
  --color-border-input: var(--orange-medium);
  --color-border-focus: var(--orange-bright);

  --scrollbar-thumb-bg: var(--orange-medium);
  --scrollbar-track-bg: var(--orange-darker);

  --border-standard: 1px solid var(--color-border);
  --border-accent: 1px solid var(--color-border-accent);
  --border-button: 1px solid var(--color-border);
  --border-radius-sm: 0;
  --border-radius-md: 0;
  --box-shadow-sm: none;
  --box-shadow-md: none;
  --button-bevel-shadow: none;

  --scanline-opacity: 0.08;
  --crt-filter: brightness(1.05) contrast(1.05);
}

/* CGA Theme (Mode 4, Palette 1 inspired) */
.theme-cga {
  --font-family-ui: 'Courier New', monospace;
  --font-family-mono: 'Courier New', monospace;
  --font-size-base: 14px;
  --font-size-editor: 13px;
  --font-size-terminal: 13px;

  --cga-black: #000000;
  --cga-cyan: #55FFFF;
  --cga-magenta: #FF55FF;
  --cga-white: #FFFFFF;

  --color-bg-app: var(--cga-black);
  --color-bg-sidebar: #111111;
  --color-bg-main: var(--cga-black);
  --color-bg-editor: var(--cga-black);
  --color-bg-terminal: var(--cga-black);
  --color-bg-button: #222222;
  --color-bg-button-hover: #333333;
  --color-bg-button-active: #444444;
  --color-bg-input: #111111;
  --color-bg-dropdown: #222222;
  --color-bg-selected: var(--cga-cyan); /* Use a bright color for selection */
  --color-bg-hover: #333333;

  --color-text-primary: var(--cga-cyan); /* Cyan text */
  --color-text-secondary: var(--cga-magenta); /* Use magenta for secondary? */
  --color-text-tertiary: #AAAAAA; /* Gray for less important */
  --color-text-terminal: var(--cga-cyan);
  --color-text-heading: var(--cga-white);
  --color-text-button: var(--cga-white);
  --color-text-link: var(--cga-magenta);
  --color-text-link-hover: var(--cga-white);
  --color-text-placeholder: #555555;
  --color-text-inverse: var(--cga-black); /* Text on selection */
  --color-text-accent: var(--cga-cyan);
  --color-text-error: var(--cga-magenta); /* Use magenta for errors */

  --color-border: var(--cga-cyan);
  --color-border-accent: var(--cga-white);
  --color-border-input: #555555;
  --color-border-focus: var(--cga-white);

  --scrollbar-thumb-bg: #444444;
  --scrollbar-track-bg: #111111;

  --border-standard: 1px solid var(--color-border);
  --border-accent: 1px solid var(--color-border-accent);
  --border-button: 1px solid #555555;
  --border-radius-sm: 0;
  --border-radius-md: 0;
  --box-shadow-sm: none;
  --box-shadow-md: none;
  --button-bevel-shadow: none;
}


/* Atari 2600 Theme */
.theme-atari {
  --font-family-ui: 'Courier New', monospace; /* Or ideally a blockier font */
  --font-family-mono: 'Courier New', monospace;
  --font-size-base: 14px;
  --font-size-editor: 13px;
  --font-size-terminal: 13px;

  --atari-black: #000000;
  --atari-cyan: #3FFFCF; /* Representative bright color */
  --atari-orange: #D87050;
  --atari-dk-gray: #444444;
  --atari-lt-gray: #AAAAAA;

  --color-bg-app: var(--atari-black);
  --color-bg-sidebar: #181818;
  --color-bg-main: var(--atari-black);
  --color-bg-editor: var(--atari-black);
  --color-bg-terminal: var(--atari-black);
  --color-bg-button: var(--atari-dk-gray);
  --color-bg-button-hover: #555555;
  --color-bg-button-active: #666666;
  --color-bg-input: #222222;
  --color-bg-dropdown: var(--atari-dk-gray);
  --color-bg-selected: var(--atari-orange); /* Orange selection */
  --color-bg-hover: #555555;

  --color-text-primary: var(--atari-cyan); /* Bright cyan text */
  --color-text-secondary: var(--atari-lt-gray);
  --color-text-tertiary: var(--atari-dk-gray);
  --color-text-terminal: var(--atari-cyan);
  --color-text-heading: var(--atari-orange);
  --color-text-button: var(--atari-lt-gray);
  --color-text-link: var(--atari-orange);
  --color-text-link-hover: var(--atari-cyan);
  --color-text-placeholder: var(--atari-dk-gray);
  --color-text-inverse: var(--atari-black); /* Text on selection */
  --color-text-accent: var(--atari-cyan);
  --color-text-error: var(--atari-orange); /* Use orange for errors */

  --color-border: var(--atari-dk-gray);
  --color-border-accent: var(--atari-cyan);
  --color-border-input: var(--atari-lt-gray);
  --color-border-focus: var(--atari-orange);

  --scrollbar-thumb-bg: #555555;
  --scrollbar-track-bg: #222222;

  --border-standard: 1px solid var(--color-border);
  --border-accent: 1px solid var(--color-border-accent);
  --border-button: 1px solid var(--atari-lt-gray);
  --border-radius-sm: 0;
  --border-radius-md: 0;
  --box-shadow-sm: none;
  --box-shadow-md: none;
  --button-bevel-shadow: none;
}

/* SNES Theme */
.theme-snes {
  --font-family-ui: system-ui, sans-serif; /* Less blocky */
  --font-family-mono: Consolas, 'Courier New', monospace;
  --font-size-base: 14px;
  --font-size-editor: 13px;
  --font-size-terminal: 13px;

  --snes-bg: #2F2F4F; /* Dark purplish gray */
  --snes-sidebar-bg: #3C3C5C;
  --snes-text: #E0E0FF; /* Light lavender text */
  --snes-accent1: #8080FF; /* Purple */
  --snes-accent2: #40C040; /* Green */
  --snes-accent3: #E04040; /* Red */
  --snes-accent4: #E0E040; /* Yellow */
  --snes-border: #505070;
  --snes-hover: #4A4A6A;

  --color-bg-app: var(--snes-bg);
  --color-bg-sidebar: var(--snes-sidebar-bg);
  --color-bg-main: var(--snes-bg);
  --color-bg-editor: var(--snes-bg);
  --color-bg-terminal: var(--snes-bg);
  --color-bg-button: var(--snes-sidebar-bg);
  --color-bg-button-hover: var(--snes-hover);
  --color-bg-button-active: var(--snes-accent1);
  --color-bg-input: var(--snes-sidebar-bg);
  --color-bg-dropdown: var(--snes-sidebar-bg);
  --color-bg-selected: var(--snes-accent1);
  --color-bg-hover: var(--snes-hover);

  --color-text-primary: var(--snes-text);
  --color-text-secondary: color-mix(in srgb, var(--snes-text) 80%, black);
  --color-text-tertiary: color-mix(in srgb, var(--snes-text) 60%, black);
  --color-text-terminal: var(--snes-text);
  --color-text-heading: var(--snes-accent4); /* Yellow heading */
  --color-text-button: var(--snes-text);
  --color-text-link: var(--snes-accent2); /* Green link */
  --color-text-link-hover: color-mix(in srgb, var(--snes-accent2) 80%, white);
  --color-text-placeholder: var(--color-text-tertiary);
  --color-text-inverse: var(--snes-bg); /* Text on selection */
  --color-text-accent: var(--snes-accent1);
  --color-text-error: var(--snes-accent3); /* Red error */

  --color-border: var(--snes-border);
  --color-border-accent: var(--snes-accent1);
  --color-border-input: var(--snes-border);
  --color-border-focus: var(--snes-accent2);

  --scrollbar-thumb-bg: var(--snes-hover);
  --scrollbar-track-bg: var(--snes-sidebar-bg);

  --border-standard: 1px solid var(--color-border);
  --border-accent: 1px solid var(--color-border-accent);
  --border-button: 1px solid var(--snes-border);
  --border-radius-sm: 3px; /* Slightly rounded */
  --border-radius-md: 5px;
  --box-shadow-sm: none;
  --box-shadow-md: none;
  --button-bevel-shadow: none;
}


/* B&W TV Theme */
.theme-bw_tv {
  --font-family-ui: 'Courier New', monospace;
  --font-family-mono: 'Courier New', monospace;
  --font-size-base: 14px;
  --font-size-editor: 13px;
  --font-size-terminal: 13px;

  --bw-black: #000000;
  --bw-dark-gray: #333333;
  --bw-gray: #888888;
  --bw-light-gray: #cccccc;
  --bw-white: #ffffff;

  --color-bg-app: var(--bw-black);
  --color-bg-sidebar: var(--bw-dark-gray);
  --color-bg-main: var(--bw-black);
  --color-bg-editor: var(--bw-black);
  --color-bg-terminal: var(--bw-black);
  --color-bg-button: var(--bw-gray);
  --color-bg-button-hover: var(--bw-light-gray);
  --color-bg-button-active: var(--bw-white);
  --color-bg-input: var(--bw-dark-gray);
  --color-bg-dropdown: var(--bw-gray);
  --color-bg-selected: var(--bw-light-gray);
  --color-bg-hover: var(--bw-gray);

  --color-text-primary: var(--bw-light-gray);
  --color-text-secondary: var(--bw-gray);
  --color-text-tertiary: var(--bw-dark-gray);
  --color-text-terminal: var(--bw-light-gray);
  --color-text-heading: var(--bw-white);
  --color-text-button: var(--bw-black); /* Black text on gray button */
  --color-text-link: var(--bw-white);
  --color-text-link-hover: var(--bw-light-gray);
  --color-text-placeholder: var(--bw-gray);
  --color-text-inverse: var(--bw-black); /* Text on selection */
  --color-text-accent: var(--bw-white);
  --color-text-error: var(--bw-white); /* White for errors */

  --color-border: var(--bw-gray);
  --color-border-accent: var(--bw-light-gray);
  --color-border-input: var(--bw-gray);
  --color-border-focus: var(--bw-white);

  --scrollbar-thumb-bg: var(--bw-gray);
  --scrollbar-track-bg: var(--bw-dark-gray);

  --border-standard: 1px solid var(--color-border);
  --border-accent: 1px solid var(--color-border-accent);
  --border-button: 1px solid var(--color-border);
  --border-radius-sm: 0;
  --border-radius-md: 0;
  --box-shadow-sm: none;
  --box-shadow-md: none;
  --button-bevel-shadow: none;

  --scanline-opacity: 0.1;
  --noise-opacity: 0.05; /* Add noise */
  --crt-filter: grayscale(100%) brightness(1.1) contrast(1.2);
}


/* --- Basic Reset & Global Styles --- */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  font-family: var(--font-family-ui);
  font-size: var(--font-size-base);
  color: var(--color-text-primary);
  background-color: var(--color-bg-app);
}

html, body, #root {
  height: 100%;
  width: 100%;
  overflow: hidden;
}

/* Apply optional CRT Filter globally */
#root {
  position: relative; /* Needed for pseudo-elements */
  filter: var(--crt-filter);
  isolation: isolate; /* Create new stacking context for z-index */
}

/* Optional Scanline Overlay */
#root.theme-pipboy::after,
#root.theme-orange::after,
#root.theme-bw_tv::after {
  content: "";
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
  background-size: 100% 4px; /* Adjust thickness */
  pointer-events: none;
  z-index: 1000;
  opacity: var(--scanline-opacity);
}

/* Optional Noise Overlay for B&W TV */
@keyframes noiseAnimation {
  0% { transform: translate(0,0); }
  10% { transform: translate(-5%,-5%); }
  20% { transform: translate(-10%,5%); }
  30% { transform: translate(5%,-10%); }
  40% { transform: translate(-5%,15%); }
  50% { transform: translate(-10%,-5%); }
  60% { transform: translate(15%,0); }
  70% { transform: translate(0,10%); }
  80% { transform: translate(-15%,0); }
  90% { transform: translate(10%,5%); }
  100% { transform: translate(5%,0); }
}

#root.theme-bw_tv::before {
  content: "";
  position: absolute;
  top: -10%; left: -10%; /* Cover more area for animation */
  width: 120%;
  height: 120%;
  /* Generate noise texture: https://css-tricks.com/snippets/css/cross-browser-noise-texture/ */
  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIzMDAiIGhlaWdodD0iMzAwIj48ZmlsdGVyIGlkPSJub2lzZSI+PGZlVHVyYnVsZW5jZSB0eXBlPSJmcmFjdGFsTm9pc2UiIGJhc2VGcmVxdWVuY3k9IjAuOCIgbnVtT2N0YXZlcz0iMyIgc3RpdGNoVGlsZXM9InN0aXRjaCIvPjxmZUNvbG9yTWF0cml4IHR5cGU9Im1hdHJpeCIgdmFsdWVzPSIwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAwIDAgMCAtMC4xIDAuMSIvPjwvZmlsdGVyPjxyZWN0IHdpZHRoPSIzMDAiIGhlaWdodD0iMzAwIiBmaWx0ZXI9InVybCgjbm9pc2UpIiBvcGFjaXR5PSIwLjUiLz48L3N2Zz4=");
  pointer-events: none;
  z-index: 1001; /* Above scanlines */
  opacity: var(--noise-opacity);
  animation: noiseAnimation .2s infinite;
}


/* Basic Scrollbar Styling */
::-webkit-scrollbar {
  width: 10px;
  height: 10px;
}
::-webkit-scrollbar-track {
  background: var(--scrollbar-track-bg);
}
::-webkit-scrollbar-thumb {
  background: var(--scrollbar-thumb-bg);
  border-radius: var(--border-radius-sm); /* Use theme radius */
}
::-webkit-scrollbar-thumb:hover {
  background: color-mix(in srgb, var(--scrollbar-thumb-bg) 80%, black);
}

/* --- Theme Specific Overrides for Components --- */

/* Win95 / mIRC Bevels */
.theme-win95 button, .theme-win95 .custom-select-trigger,
.theme-mirc button, .theme-mirc .custom-select-trigger {
  border: none; /* Remove default border */
  box-shadow: inset -1px -1px var(--win95-bevel-shadow-darker, transparent),
              inset 1px 1px var(--win95-bevel-shadow-light, transparent),
              inset -2px -2px var(--win95-bevel-shadow-dark, transparent),
              inset 2px 2px var(--win95-bevel-shadow-lighter, transparent);
  padding: calc(var(--spacing-xs) + 1px) calc(var(--spacing-sm) + 1px); /* Adjust padding for border */
}
.theme-win95 button:active, .theme-win95 .custom-select-trigger:active,
.theme-mirc button:active, .theme-mirc .custom-select-trigger:active {
   /* Inverted bevel for pressed state */
   box-shadow: inset 1px 1px var(--win95-bevel-shadow-darker, transparent),
               inset -1px -1px var(--win95-bevel-shadow-light, transparent),
               inset 2px 2px var(--win95-bevel-shadow-dark, transparent),
               inset -2px -2px var(--win95-bevel-shadow-lighter, transparent);
   padding: calc(var(--spacing-xs) + 2px) var(--spacing-sm) var(--spacing-xs) calc(var(--spacing-sm) + 2px); /* Shift text slightly */
}

/* Input field bevel */
.theme-win95 input[type="text"], .theme-win95 textarea, .theme-win95 .custom-select-options,
.theme-mirc input[type="text"], .theme-mirc textarea, .theme-mirc .custom-select-options {
  border: none;
   box-shadow: inset 1px 1px var(--win95-bevel-shadow-dark, transparent), /* Inset dark */
               inset -1px -1px var(--win95-bevel-shadow-light, transparent), /* Inset light */
               1px 1px 0 1px var(--win95-bevel-shadow-darker, transparent); /* Outer bottom/right black border */
   border-radius: 0;
}
.theme-win95 .custom-select-options,
.theme-mirc .custom-select-options {
     bottom: calc(100% + 1px); /* Adjust position slightly for bevel */
     box-shadow: inset 1px 1px var(--win95-bevel-shadow-dark, transparent),
                 inset -1px -1px var(--win95-bevel-shadow-light, transparent),
                 1px 1px 0 1px var(--win95-bevel-shadow-darker, transparent), /* Bottom/right */
                 -1px -1px 0 1px var(--win95-bevel-shadow-lighter, transparent); /* Top/left */
}


/* Win95/mIRC Scrollbars need more specific styling for bevels */
.theme-win95 ::-webkit-scrollbar-track,
.theme-mirc ::-webkit-scrollbar-track {
   background: #a0a0a0; /* Pattern or simple color */
   border: none;
}
.theme-win95 ::-webkit-scrollbar-thumb,
.theme-mirc ::-webkit-scrollbar-thumb {
    background-color: var(--color-bg-button);
    box-shadow: inset -1px -1px var(--win95-bevel-shadow-darker, transparent),
              inset 1px 1px var(--win95-bevel-shadow-light, transparent),
              inset -2px -2px var(--win95-bevel-shadow-dark, transparent),
              inset 2px 2px var(--win95-bevel-shadow-lighter, transparent);
    border: none;
    border-radius: 0;
}

/* Pip-Boy Specific Styles */
.theme-pipboy button, .theme-pipboy .custom-select-trigger {
  border: 1px solid var(--color-border);
  background: transparent;
  transition: background-color 0.1s ease-in-out;
}
.theme-pipboy button:hover, .theme-pipboy .custom-select-trigger:hover {
  background-color: var(--color-bg-button-hover);
}
.theme-pipboy button:active, .theme-pipboy .custom-select-trigger:active {
  background-color: var(--color-bg-button-active);
}
.theme-pipboy .custom-select-options {
    border: 1px solid var(--color-border);
    background-color: var(--pipboy-bg-lighter); /* Slightly different bg */
}
.theme-pipboy input, .theme-pipboy textarea {
   border: 1px solid var(--color-border);
   background-color: var(--color-bg-input);
   color: var(--color-text-primary);
}
.theme-pipboy ::-webkit-scrollbar-thumb {
    border: 1px solid var(--pipboy-green-darker);
}

/* Default Button / Input / Select styles for other themes */
button, .custom-select-trigger {
    background-color: var(--color-bg-button);
    border: var(--border-button);
    color: var(--color-text-button);
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: background-color 0.15s ease, border-color 0.15s ease;
    font-size: inherit;
}
button:hover, .custom-select-trigger:hover {
    background-color: var(--color-bg-button-hover);
}
button:active, .custom-select-trigger:active {
    background-color: var(--color-bg-button-active);
}
input[type="text"], textarea {
    background-color: var(--color-bg-input);
    border: 1px solid var(--color-border-input);
    color: var(--color-text-primary);
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--border-radius-sm);
    font-family: var(--font-family-mono);
    font-size: var(--font-size-sm);
}
input[type="text"]:focus, textarea:focus {
    outline: none;
    border-color: var(--color-border-focus);
    box-shadow: 0 0 0 1px var(--color-border-focus);
}
.custom-select-options {
    background-color: var(--color-bg-dropdown);
    border: 1px solid var(--color-border-input);
    border-radius: var(--border-radius-sm);
    box-shadow: var(--box-shadow-sm);
}
.custom-select-option:hover {
    background-color: var(--color-bg-hover);
}
.custom-select-option.selected {
    background-color: var(--color-bg-selected);
    color: var(--color-text-inverse);
}

/* --- END FILE: src/renderer/index.css --- */
--- END FILE: src/renderer/index.css ---

--- START FILE: src/renderer/components/TerminalTabContainer.tsx ---
// src/renderer/components/TerminalTabContainer.tsx
import React, { useRef, useEffect } from "react";
import TerminalTab from "./TerminalTab";
import { useTerminals, OpenTerminal } from "../contexts/TerminalContext";
import { FaPlus } from "react-icons/fa"; // Remove FaBroom
import "./TabContainer.css"; // Reuse editor tab container styles

const TerminalTabContainer: React.FC = () => {
  const {
    openTerminals,
    activeTerminalId,
    setActiveTerminal,
    closeTerminal,
    createTerminal, // Function to create a new terminal
    // clearActiveTerminal, // Removed
  } = useTerminals();
  const containerRef = useRef<HTMLDivElement>(null);
  const activeTabRef = useRef<HTMLDivElement>(null);

  // Effect to scroll the active tab into view when it changes
  useEffect(() => {
    const timerId = setTimeout(() => {
      if (activeTabRef.current) {
        activeTabRef.current.scrollIntoView({
          behavior: "smooth",
          block: "nearest",
          inline: "nearest",
        });
      }
    }, 0);
    return () => clearTimeout(timerId);
  }, [activeTerminalId]);


  const handleAddNewTerminal = () => {
    createTerminal(); // Call context function
  };


  return (
    <div
      ref={containerRef}
      className="tab-container terminal-tab-container"
      role="tablist"
      aria-label="Open terminal tabs"
    >
      {openTerminals.map((term: OpenTerminal) => (
        <TerminalTab
          key={term.id}
          ref={term.id === activeTerminalId ? activeTabRef : null}
          terminalId={term.id}
          title={term.title}
          isActive={term.id === activeTerminalId}
          isLoading={term.isLoading}
          hasExited={term.exitCode !== null && term.exitCode !== undefined} // Adjusted check for exit code
          onClick={setActiveTerminal}
          onClose={closeTerminal}
          // Add props for isLoading, hasExited if needed for styling
        />
      ))}
      {/* Add New Terminal Button */}
      <button
        className="add-tab-button icon-button" // Style similarly to other icon buttons
        onClick={handleAddNewTerminal}
        title="New Terminal Tab"
        aria-label="Create New Terminal Tab"
      >
        <FaPlus />
      </button>
    </div>
  );
};

export default TerminalTabContainer;
--- END FILE: src/renderer/components/TerminalTabContainer.tsx ---

--- START FILE: src/renderer/components/TerminalPanel.tsx ---
// src/renderer/components/TerminalPanel.tsx
import React, { useRef, useEffect, useCallback, useState } from "react";
import { Terminal, ITerminalOptions, ITheme } from "xterm";
import { FitAddon } from "xterm-addon-fit";
import "xterm/css/xterm.css";
import { FaBroom } from 'react-icons/fa'; // Import clear icon
import { useTheme, ThemeName } from "../contexts/ThemeContext";
import { useTerminals, OpenTerminal } from "../contexts/TerminalContext"; // Import OpenTerminal type
import process from "process"; // Assuming polyfill is working

// Base options
const baseTerminalOptions: Omit<ITerminalOptions, "theme"> = {
  cursorBlink: true,
  fontFamily: "var(--font-family-mono)",
  scrollback: 1000,
  convertEol: true,
  windowsMode: typeof process !== "undefined" && process.platform === "win32",
  allowProposedApi: true,
};

// Terminal themes
const terminalThemes: Record<ThemeName, ITheme> = {
  light: {
    background: "#ffffff",
    foreground: "#333333",
    cursor: "#333333",
    selectionBackground: "#d5e5f6",
    selectionForeground: "#000000",
    black: "#000000",
    red: "#cd3131",
    green: "#0dbc79",
    yellow: "#e5e510",
    blue: "#2472c8",
    magenta: "#bc3fbc",
    cyan: "#11a8cd",
    white: "#e5e5e5",
    brightBlack: "#666666",
    brightRed: "#f14c4c",
    brightGreen: "#23d18b",
    brightYellow: "#f5f543",
    brightBlue: "#3b8eea",
    brightMagenta: "#d670d6",
    brightCyan: "#29b8db",
    brightWhite: "#e5e5e5",
  },
  dark: {
    background: "#1e1e1e",
    foreground: "#cccccc",
    cursor: "#cccccc",
    selectionBackground: "#094771",
    selectionForeground: "#ffffff",
    black: "#000000",
    red: "#cd3131",
    green: "#0dbc79",
    yellow: "#e5e510",
    blue: "#2472c8",
    magenta: "#bc3fbc",
    cyan: "#11a8cd",
    white: "#e5e5e5",
    brightBlack: "#666666",
    brightRed: "#f14c4c",
    brightGreen: "#23d18b",
    brightYellow: "#f5f543",
    brightBlue: "#3b8eea",
    brightMagenta: "#d670d6",
    brightCyan: "#29b8db",
    brightWhite: "#e5e5e5",
  },
  win95: {
    background: "#000080",
    foreground: "#c0c0c0",
    cursor: "#c0c0c0",
    selectionBackground: "#c0c0c0",
    selectionForeground: "#000080",
    black: "#000000",
    red: "#800000",
    green: "#008000",
    yellow: "#808000",
    blue: "#000080",
    magenta: "#800080",
    cyan: "#008080",
    white: "#c0c0c0",
    brightBlack: "#808080",
    brightRed: "#ff0000",
    brightGreen: "#00ff00",
    brightYellow: "#ffff00",
    brightBlue: "#0000ff",
    brightMagenta: "#ff00ff",
    brightCyan: "#00ffff",
    brightWhite: "#ffffff",
  },
  pipboy: {
    background: "#0a1a0f",
    foreground: "#15ff60",
    cursor: "#15ff60",
    cursorAccent: "#0a1a0f",
    selectionBackground: "#10b445",
    selectionForeground: "#0a1a0f",
    black: "#050d07",
    red: "#0a702a",
    green: "#15ff60",
    yellow: "#10b445",
    blue: "#0a702a",
    magenta: "#10b445",
    cyan: "#15ff60",
    white: "#a0ffc0",
    brightBlack: "#0a702a",
    brightRed: "#10b445",
    brightGreen: "#a0ffc0",
    brightYellow: "#e0ffe0",
    brightBlue: "#10b445",
    brightMagenta: "#a0ffc0",
    brightCyan: "#e0ffe0",
    brightWhite: "#ffffff",
  },
  mirc: {
    background: "#000000",
    foreground: "#00ff00",
    cursor: "#00ff00",
    selectionBackground: "#008000",
    selectionForeground: "#ffffff",
    black: "#000000",
    red: "#800000",
    green: "#008000",
    yellow: "#808000",
    blue: "#000080",
    magenta: "#800080",
    cyan: "#008080",
    white: "#c0c0c0",
    brightBlack: "#808080",
    brightRed: "#ff0000",
    brightGreen: "#00ff00",
    brightYellow: "#ffff00",
    brightBlue: "#0000ff",
    brightMagenta: "#ff00ff",
    brightCyan: "#00ffff",
    brightWhite: "#ffffff",
  },
  qbasic: {
    background: "#0000AA",
    foreground: "#FFFF55",
    cursor: "#FFFFFF",
    selectionBackground: "#555555",
    selectionForeground: "#FFFFFF",
    black: "#000000",
    red: "#AA0000",
    green: "#00AA00",
    yellow: "#AA5500",
    blue: "#0000AA",
    magenta: "#AA00AA",
    cyan: "#00AAAA",
    white: "#AAAAAA",
    brightBlack: "#555555",
    brightRed: "#FF5555",
    brightGreen: "#55FF55",
    brightYellow: "#FFFF55",
    brightBlue: "#5555FF",
    brightMagenta: "#FF55FF",
    brightCyan: "#55FFFF",
    brightWhite: "#FFFFFF",
  },
  orange: {
    background: "#201500",
    foreground: "#FFA500",
    cursor: "#FFA500",
    cursorAccent: "#201500",
    selectionBackground: "#D98C00",
    selectionForeground: "#201500",
    black: "#100A00",
    red: "#D98C00",
    green: "#FFA500",
    yellow: "#FFC04D",
    blue: "#D98C00",
    magenta: "#FFA500",
    cyan: "#FFC04D",
    white: "#FFE0B3",
    brightBlack: "#5A3D00",
    brightRed: "#FFC04D",
    brightGreen: "#FFE0B3",
    brightYellow: "#FFF5E0",
    brightBlue: "#FFC04D",
    brightMagenta: "#FFE0B3",
    brightCyan: "#FFF5E0",
    brightWhite: "#FFFFFF",
  },
  cga: {
    background: "#000000",
    foreground: "#55FFFF",
    cursor: "#FFFFFF",
    selectionBackground: "#55FFFF",
    selectionForeground: "#000000",
    black: "#000000",
    red: "#FF5555",
    green: "#55FF55",
    yellow: "#FFFF55",
    blue: "#5555FF",
    magenta: "#FF55FF",
    cyan: "#55FFFF",
    white: "#FFFFFF",
    brightBlack: "#555555",
    brightRed: "#FF5555",
    brightGreen: "#55FF55",
    brightYellow: "#FFFF55",
    brightBlue: "#5555FF",
    brightMagenta: "#FF55FF",
    brightCyan: "#55FFFF",
    brightWhite: "#FFFFFF",
  },
  atari: {
    background: "#000000",
    foreground: "#3FFFCF",
    cursor: "#D87050",
    selectionBackground: "#D87050",
    selectionForeground: "#000000",
    black: "#000000",
    red: "#D87050",
    green: "#3FFFCF",
    yellow: "#D8D850",
    blue: "#5070D8",
    magenta: "#D870D8",
    cyan: "#3FFFCF",
    white: "#AAAAAA",
    brightBlack: "#444444",
    brightRed: "#F0A080",
    brightGreen: "#7FFFEF",
    brightYellow: "#F0F080",
    brightBlue: "#80A0F0",
    brightMagenta: "#F0A0F0",
    brightCyan: "#7FFFEF",
    brightWhite: "#FFFFFF",
  },
  snes: {
    background: "#2F2F4F",
    foreground: "#E0E0FF",
    cursor: "#E0E040",
    selectionBackground: "#8080FF",
    selectionForeground: "#2F2F4F",
    black: "#101020",
    red: "#E04040",
    green: "#40C040",
    yellow: "#E0E040",
    blue: "#8080FF",
    magenta: "#C080FF",
    cyan: "#80C0FF",
    white: "#E0E0FF",
    brightBlack: "#505070",
    brightRed: "#FF7070",
    brightGreen: "#70F070",
    brightYellow: "#F0F070",
    brightBlue: "#B0B0FF",
    brightMagenta: "#F0B0FF",
    brightCyan: "#B0F0FF",
    brightWhite: "#FFFFFF",
  },
  bw_tv: {
    background: "#000000",
    foreground: "#cccccc",
    cursor: "#ffffff",
    selectionBackground: "#cccccc",
    selectionForeground: "#000000",
    black: "#000000",
    red: "#888888",
    green: "#aaaaaa",
    yellow: "#bbbbbb",
    blue: "#888888",
    magenta: "#aaaaaa",
    cyan: "#bbbbbb",
    white: "#cccccc",
    brightBlack: "#555555",
    brightRed: "#aaaaaa",
    brightGreen: "#cccccc",
    brightYellow: "#dddddd",
    brightBlue: "#aaaaaa",
    brightMagenta: "#cccccc",
    brightCyan: "#dddddd",
    brightWhite: "#ffffff",
  },
};

interface TerminalPanelProps {
  id: string;
  isActive: boolean;
}

const TerminalPanel: React.FC<TerminalPanelProps> = ({ id, isActive }) => {
  const { theme } = useTheme();
  const {
    writeToActiveTerminal,
    resizeActiveTerminal,
    getActiveTerminal,
    clearActiveTerminal,
    openTerminals // Get the list to find the current terminal's state
  } = useTerminals();

  const terminalMountRef = useRef<HTMLDivElement | null>(null);
  const terminalInstanceRef = useRef<Terminal | null>(null);
  const fitAddonRef = useRef<FitAddon | null>(null);
  // Local isReady state is still useful for effect logic, but not for button visibility
  const [isReady, setIsReady] = useState(() => {
    const termState = getActiveTerminal(); // Check initial state from context
    return termState?.id === id ? termState.isReady : false;
  });
  const initialCheckDone = useRef(false);
  const resizeTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const xtermResizeListener = useRef<ReturnType<Terminal["onResize"]> | null>(
    null
  );
  const activationTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // --- Get the *current* state of this terminal directly from context ---
  // This will update whenever the context updates, triggering re-renders
  const currentTerminalState: OpenTerminal | undefined = openTerminals.find(t => t.id === id);

  // Helper function to get terminal font size
  const getTerminalFontSize = useCallback((): number => {
    if (typeof document === "undefined") return 13;
    try {
      const fontSizeValue = getComputedStyle(
        document.documentElement
      ).getPropertyValue("--font-size-terminal");
      return parseInt(fontSizeValue?.replace("px", "").trim() || "13", 10);
    } catch (e) {
      return 13;
    }
  }, []);

  // Helper function to just fit the addon
  const fitTerminal = useCallback(() => {
    if (fitAddonRef.current && terminalInstanceRef.current) {
      try {
        fitAddonRef.current.fit();
      } catch (e) {
        console.warn(`TerminalPanel [${id}]: Error during fitTerminal():`, e);
      }
    }
  }, [id]);

  // --- Effect 1: Create Frontend Terminal Instance & Addon (Mount Logic) ---
  useEffect(() => {
    if (!terminalInstanceRef.current && terminalMountRef.current) {
      console.log(
        `TerminalPanel [${id}]: Effect 1 - Creating Frontend Instance.`
      );
      const container = terminalMountRef.current;
      container.innerHTML = "";

      const term = new Terminal({
        ...baseTerminalOptions,
        theme: terminalThemes[theme] || terminalThemes["dark"],
        fontSize: getTerminalFontSize(),
      });
      const addon = new FitAddon();
      terminalInstanceRef.current = term;
      fitAddonRef.current = addon;
      term.loadAddon(addon);
      term.open(container);
      console.log(`TerminalPanel [${id}]: Effect 1 - Instance attached.`);
      // Initial fit deferred
    }
    return () => {
      console.log(`TerminalPanel [${id}]: Effect 1 Cleanup - Unmounting.`);
      if (resizeTimeoutRef.current) clearTimeout(resizeTimeoutRef.current);
      if (activationTimeoutRef.current)
        clearTimeout(activationTimeoutRef.current); // Clear activation timeout too
      try {
        xtermResizeListener.current?.dispose();
        xtermResizeListener.current = null;
      } catch (e) {}
      try {
        fitAddonRef.current?.dispose();
        fitAddonRef.current = null;
      } catch (e) {}
      if (terminalInstanceRef.current) {
        terminalInstanceRef.current.dispose();
        terminalInstanceRef.current = null;
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id]);

  // --- Effect 2: Setup Listeners (IPC, Input, Xterm Resize, Clear), Initial State Check ---
  useEffect(() => {
    const term = terminalInstanceRef.current;
    if (!term) return;

    console.log(`TerminalPanel [${id}]: Effect 2 - Setting up listeners.`);
    let isEffectMounted = true;
    xtermResizeListener.current?.dispose();

    // Xterm's onResize Listener -> Notifies Backend
    // Use local isReady here to prevent sending resize before backend confirms
    xtermResizeListener.current = term.onResize(({ cols, rows }) => {
      if (isActive && isReady) {
        if (cols > 0 && rows > 0) {
          resizeActiveTerminal(cols, rows);
        }
      }
    });

    // Input Forwarding
    const dataListener = term.onData((data: string) => {
      if (isActive && isEffectMounted) writeToActiveTerminal(data);
    });

    // Event Listeners (IPC via custom events)
    const handleDataEvent = (event: CustomEvent<{ data: string }>) => {
      if (isEffectMounted && terminalInstanceRef.current) {
        terminalInstanceRef.current.write(event.detail.data);
        // Update local isReady state if context confirms readiness
        // Use direct context check here too, or rely on component re-render
        const ctxState = openTerminals.find(t => t.id === id); // Check live context state
        if (ctxState?.isReady && !isReady) {
           setIsReady(true); // Sync local state if needed
        }
      }
    };
    const dataEventName = `terminal-data-${id}`;
    window.addEventListener(dataEventName, handleDataEvent as EventListener);

    const handleExitEvent = (event: CustomEvent<{ code?: number | null }>) => {
      if (isEffectMounted && terminalInstanceRef.current) {
        setIsReady(false); // Update local state
        if (!initialCheckDone.current) initialCheckDone.current = true;
        terminalInstanceRef.current.writeln(
          `\n\n[Process exited with code ${event.detail.code ?? "N/A"}]`
        );
        terminalInstanceRef.current.options.cursorBlink = false;
        terminalInstanceRef.current.options.disableStdin = true;
      }
    };
    const exitEventName = `terminal-exit-${id}`;
    window.addEventListener(exitEventName, handleExitEvent as EventListener);

    const handleErrorEvent = (event: CustomEvent<{ error: string }>) => {
      if (isEffectMounted && terminalInstanceRef.current) {
        setIsReady(false); // Update local state
        if (!initialCheckDone.current) initialCheckDone.current = true;
        terminalInstanceRef.current.writeln(
          `\n\n[Backend Error: ${event.detail.error}]`
        );
      }
    };
    const errorEventName = `terminal-error-${id}`;
    window.addEventListener(errorEventName, handleErrorEvent as EventListener);

    // Listener for Clear Event
    const handleClearEvent = () => {
      if (isEffectMounted && terminalInstanceRef.current) {
        console.log(
          `TerminalPanel [${id}]: Received clear event. Clearing terminal buffer.`
        );
        terminalInstanceRef.current.clear();
      }
    };
    const clearEventName = `terminal-clear-${id}`;
    window.addEventListener(clearEventName, handleClearEvent as EventListener);


    // Initial State Check (Sync local isReady)
    if (!initialCheckDone.current && term) {
       // Use currentTerminalState fetched outside useEffect
      if (currentTerminalState) {
        console.log(`TerminalPanel [${id}]: Effect 2 - Initial state check.`);
        // Sync local state with context state found during this render cycle
        if(currentTerminalState.isReady !== isReady) {
            setIsReady(currentTerminalState.isReady);
        }
        if (!currentTerminalState.isReady) {
          // Display initial messages based on context state
          if (currentTerminalState.isLoading)
            term.writeln("Connecting to backend shell...");
          else if (currentTerminalState.error)
            term.writeln(`\n\n[Failed to connect: ${currentTerminalState.error}]`);
          else if (currentTerminalState.exitCode !== undefined) {
            term.writeln(
              `\n\n[Process exited with code ${
                currentTerminalState.exitCode ?? "N/A"
              }]`
            );
            term.options.cursorBlink = false;
            term.options.disableStdin = true;
          }
        }
        initialCheckDone.current = true;
      }
    }
    // Cleanup
    return () => {
      isEffectMounted = false;
      console.log(`TerminalPanel [${id}]: Effect 2 Cleanup.`);
      try {
        xtermResizeListener.current?.dispose();
        xtermResizeListener.current = null;
      } catch (e) {}
      try {
        dataListener?.dispose();
      } catch (e) {}
      window.removeEventListener(
        dataEventName,
        handleDataEvent as EventListener
      );
      window.removeEventListener(
        exitEventName,
        handleExitEvent as EventListener
      );
      window.removeEventListener(
        errorEventName,
        handleErrorEvent as EventListener
      );
      window.removeEventListener(
        clearEventName,
        handleClearEvent as EventListener
      ); // Remove clear listener
    };
    // Add openTerminals to dependency array to re-run if context changes
    // Add currentTerminalState as dependency (or derived values like currentTerminalState.isReady)
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    id,
    isActive,
    isReady, // Keep local isReady for internal effect logic guards
    writeToActiveTerminal,
    resizeActiveTerminal,
    openTerminals, // Add this dependency
    currentTerminalState?.isReady // Depend on the context readiness
  ]);

  // --- Effect 3: Handle Container Resizing (Debounced Observer on the Wrapper) ---
  useEffect(() => {
    const wrapperElement = terminalMountRef.current?.parentElement;
    if (!wrapperElement || !terminalInstanceRef.current || !fitAddonRef.current)
      return;

    const handleResize = () => {
      if (resizeTimeoutRef.current) clearTimeout(resizeTimeoutRef.current);
      resizeTimeoutRef.current = setTimeout(() => {
        fitTerminal();
      }, 100);
    };

    console.log(
      `TerminalPanel [${id}]: Effect 3 - Setting up ResizeObserver on wrapper.`
    );
    const resizeObserver = new ResizeObserver(handleResize);
    resizeObserver.observe(wrapperElement);
    requestAnimationFrame(() => fitTerminal()); // Initial fit

    // Cleanup
    return () => {
      console.log(
        `TerminalPanel [${id}]: Effect 3 Cleanup - Disconnecting ResizeObserver.`
      );
      if (resizeTimeoutRef.current) clearTimeout(resizeTimeoutRef.current);
      if (wrapperElement) resizeObserver.unobserve(wrapperElement);
      resizeObserver.disconnect();
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [id, fitTerminal]);

  // --- Effect 4: Handle Theme/Font Changes ---
  useEffect(() => {
    const term = terminalInstanceRef.current;
    if (!term) return;
    let optionsChanged = false;
    const currentThemeName = theme;
    const currentTerminalTheme =
      terminalThemes[currentThemeName] || terminalThemes["dark"];
    const currentFontSize = getTerminalFontSize();

    if (term.options.theme !== currentTerminalTheme) {
      term.options.theme = currentTerminalTheme;
      optionsChanged = true;
    }
    if (term.options.fontSize !== currentFontSize) {
      term.options.fontSize = currentFontSize;
      optionsChanged = true;
    }
    if (optionsChanged) {
      console.log(
        `TerminalPanel [${id}]: Effect 4 - Options changed, refitting frontend.`
      );
      requestAnimationFrame(() => fitTerminal()); // Fit frontend only
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [theme, id, getTerminalFontSize, fitTerminal]);

  // --- Effect 5: Handle Activation (Fit, Explicit Backend Resize, Refresh, Scroll, Focus) ---
  useEffect(() => {
    const term = terminalInstanceRef.current;
    let currentActivationTimeoutId: NodeJS.Timeout | null = null;

    if (isActive && term) {
      console.log(`TerminalPanel [${id}]: Effect 5 - Activating panel.`);
      const runActivationSteps = () => {
        activationTimeoutRef.current = null;
        if (!terminalInstanceRef.current || !fitAddonRef.current) return;
        const currentTerm = terminalInstanceRef.current;

        console.log(
          `TerminalPanel [${id}]: Effect 5 - Running activation steps.`
        );
        try {
          console.log(`TerminalPanel [${id}]: Effect 5 - Fitting.`);
          fitTerminal(); // Triggers onResize internally
          const calculatedCols = currentTerm.cols;
          const calculatedRows = currentTerm.rows;
          console.log(
            `TerminalPanel [${id}]: Effect 5 - Fit complete. Dims: ${calculatedCols}x${calculatedRows}`
          );

          // Use local isReady guard here is okay
          if (isReady && calculatedCols > 0 && calculatedRows > 0) {
            console.log(
              `TerminalPanel [${id}]: Effect 5 - EXPLICIT backend resize notification: ${calculatedCols}x${calculatedRows}.`
            );
            resizeActiveTerminal(calculatedCols, calculatedRows);
          }

          if (currentTerm.rows > 0) {
            currentTerm.refresh(0, currentTerm.rows - 1);
            console.log(`TerminalPanel [${id}]: Effect 5 - Refresh complete.`);
          }

          const cursorY = currentTerm.buffer.active.cursorY;
          if (cursorY >= 0 && cursorY < currentTerm.buffer.active.length) {
            currentTerm.scrollToLine(cursorY);
          } else {
            currentTerm.scrollToBottom();
          }

          // Use local isReady guard here
          if (isReady) {
            console.log(`TerminalPanel [${id}]: Effect 5 - Focusing.`);
            currentTerm.focus();
          }
          console.log(
            `TerminalPanel [${id}]: Effect 5 - Activation sequence finished.`
          );
        } catch (e) {
          console.warn(
            `TerminalPanel [${id}]: Effect 5 - Error during activation sequence:`,
            e
          );
        }
      };

      currentActivationTimeoutId = setTimeout(runActivationSteps, 100);
      activationTimeoutRef.current = currentActivationTimeoutId;
    }

    // Cleanup
    return () => {
      if (activationTimeoutRef.current) {
        clearTimeout(activationTimeoutRef.current);
        activationTimeoutRef.current = null;
      }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isActive, isReady, id, fitTerminal, resizeActiveTerminal]); // Keep isReady dependency for guards within effect

  // Handler for the clear button
  const handleClearClick = (e: React.MouseEvent) => {
      e.stopPropagation(); // Prevent focus shifts if needed
      console.log(`TerminalPanel [${id}]: Clear button clicked.`);
      clearActiveTerminal(); // Call the context function
  };

  // --- Render: Wrapper + Clear Button + Mount Point ---
  return (
    // Wrapper div for positioning
    <div className="terminal-panel-content-wrapper">
      {/* --- MODIFIED CONDITION --- */}
      {/* Show button if:
          - This panel is the active one (`isActive` prop)
          - The *context* says this terminal is ready (`currentTerminalState?.isReady`)
          - The *context* says this terminal has not exited (`currentTerminalState?.exitCode === undefined`)
      */}
      {isActive && currentTerminalState?.isReady && currentTerminalState?.exitCode === undefined && (
        <button
          className="terminal-clear-button-overlay icon-button"
          onClick={handleClearClick}
          title="Clear Terminal Scrollback and Viewport"
          aria-label="Clear Terminal"
        >
          <FaBroom />
        </button>
      )}
      {/* Mount point remains the same */}
      <div
        ref={terminalMountRef}
        className="terminal-mount-point" // Original class for xterm mounting
        style={{ width: "100%", height: "100%", overflow: "hidden" }}
      ></div>
    </div>
  );
};

export default TerminalPanel;
--- END FILE: src/renderer/components/TerminalPanel.tsx ---

--- START FILE: src/renderer/components/StatusBar.tsx ---
// --- START FILE: src/renderer/components/StatusBar.tsx ---
import React, { useState, useEffect } from 'react'; // Import useState, useEffect
import path from 'path-browserify';
import { useEditor } from '../contexts/EditorContext';
import './StatusBar.css'; // Import styles

// Simple Language Mapping Utility (copied from EditorPanel for now)
// TODO: Extract to a shared utility file later
const getLanguageFromPath = (filePath: string | null): string => {
    if (!filePath) return 'Plain Text'; // More user-friendly default
    const extension = filePath.split('.').pop()?.toLowerCase();
    switch (extension) {
        case 'js': case 'jsx': return 'JavaScript';
        case 'ts': case 'tsx': return 'TypeScript';
        case 'json': return 'JSON';
        case 'css': return 'CSS';
        case 'html': case 'htm': return 'HTML';
        case 'md': case 'markdown': return 'Markdown';
        case 'py': return 'Python';
        case 'java': return 'Java';
        case 'c': case 'h': return 'C';
        case 'cpp': case 'hpp': return 'C++';
        case 'cs': return 'C#';
        case 'sh': return 'Shell Script';
        case 'xml': return 'XML';
        case 'yaml': case 'yml': return 'YAML';
        case 'sql': return 'SQL';
        // Add more user-friendly names
        default: return 'Plain Text';
    }
};

// Helper to format time with leading zeros
const formatTime = (date: Date): string => {
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');
    return `${hours}:${minutes}:${seconds}`;
};


const StatusBar: React.FC = () => {
    const { activeFilePath, getActiveFile, cursorPosition } = useEditor();
    const activeFile = getActiveFile();
    const [currentTime, setCurrentTime] = useState<string>(formatTime(new Date())); // State for time

    // Effect to update the time every second
    useEffect(() => {
        const timerId = setInterval(() => {
            setCurrentTime(formatTime(new Date()));
        }, 1000); // Update every 1000ms (1 second)

        // Cleanup interval on component unmount
        return () => {
            clearInterval(timerId);
        };
    }, []); // Empty dependency array ensures this runs only once on mount


    const fileName = activeFilePath ? path.basename(activeFilePath) : 'No file selected';
    const isDirty = activeFile?.isDirty ?? false;
    const isLoading = activeFile?.isLoading ?? false;
    const errorMessage = activeFile?.error ?? null;

    const line = cursorPosition?.lineNumber ?? 0;
    const column = cursorPosition?.column ?? 0;
    const detectedLanguage = getLanguageFromPath(activeFilePath);

    return (
        <div className="status-bar">
            {/* Left Side: File Status */}
            <div className="status-bar-left">
                <span className="status-item file-path" title={activeFilePath ?? ''}>
                    {isLoading ? 'Loading...' : (errorMessage ? `Error: ${fileName}` : fileName)}
                    {isDirty && !isLoading && !errorMessage && <span className="dirty-indicator">*</span>}
                </span>
                {errorMessage && (
                     <span className="status-item error-message" title={errorMessage}>
                         ⚠️ Error
                     </span>
                )}
            </div>

            {/* Right Side: Editor Info & Time */}
            <div className="status-bar-right">
                 {/* Show Ln/Col only if a file is active and we have position info */}
                 {activeFilePath && !isLoading && !errorMessage && line > 0 && column > 0 && (
                      <span className="status-item cursor-position" title="Line number, Column number">
                          Ln {line}, Col {column}
                      </span>
                  )}
                  {/* Show language only if a file is active */}
                  {activeFilePath && !isLoading && !errorMessage && (
                    <span className="status-item language" title="Detected File Language">
                        {detectedLanguage}
                    </span>
                  )}
                  <span className="status-item encoding" title="File Encoding">UTF-8</span> {/* Placeholder */}
                  <span className="status-item time" title="Current Time">{currentTime}</span>
            </div>
        </div>
    );
};

export default StatusBar;
// --- END FILE: src/renderer/components/StatusBar.tsx ---
--- END FILE: src/renderer/components/StatusBar.tsx ---

--- START FILE: src/renderer/components/TabContainer.tsx ---
// --- START FILE: src/renderer/components/TabContainer.tsx ---
import React, { useRef, useEffect } from 'react';
import Tab from './Tab';
import { useEditor, OpenFile } from '../contexts/EditorContext';
import './TabContainer.css';

const TabContainer: React.FC = () => {
    const { openFiles, activeFilePath, setActiveFile, closeFile } = useEditor();
    const containerRef = useRef<HTMLDivElement>(null);
    const activeTabRef = useRef<HTMLDivElement>(null);

    // Effect to scroll the active tab into view when it changes
    useEffect(() => {
        // Introduce a slight delay using setTimeout to ensure DOM updates
        const timerId = setTimeout(() => {
            if (activeTabRef.current) {
                console.log(`Attempting to scroll tab ${activeFilePath} into view.`);
                activeTabRef.current.scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest',
                    inline: 'nearest', // 'start' or 'center' might also work if 'nearest' fails
                });
            } else {
                 console.log(`Active tab ref not found for ${activeFilePath} when trying to scroll.`);
            }
        }, 0); // 0ms delay pushes execution after current browser tick

        // Cleanup the timer if the effect re-runs before the timeout finishes
        return () => clearTimeout(timerId);

    }, [activeFilePath]); // Dependency remains the same

    if (openFiles.length === 0) {
        return null;
    }

    return (
        <div ref={containerRef} className="tab-container" role="tablist" aria-label="Open file tabs">
            {openFiles.map((file: OpenFile) => (
                <Tab
                    key={file.path}
                    ref={file.path === activeFilePath ? activeTabRef : null}
                    filePath={file.path}
                    isActive={file.path === activeFilePath}
                    isDirty={file.isDirty}
                    onClick={setActiveFile}
                    onClose={closeFile}
                />
            ))}
        </div>
    );
};

export default TabContainer;
// --- END FILE: src/renderer/components/TabContainer.tsx ---
--- END FILE: src/renderer/components/TabContainer.tsx ---

--- START FILE: src/renderer/components/Sidebar.tsx ---
// --- START FILE: src/renderer/components/Sidebar.tsx ---
import React, { useState, useEffect, useCallback } from 'react';
import path from 'path-browserify';
import { useTheme, ThemeName } from '../contexts/ThemeContext';
import { useEditor } from '../contexts/EditorContext'; // Import the hook
import CustomSelect from './CustomSelect';
import FileTreeNode from './FileTreeNode';
import type { DirectoryEntry } from '../../shared.types';
import { FaFolderOpen, FaLevelUpAlt } from 'react-icons/fa';

// Theme options
const themeOptions: { value: ThemeName; label: string }[] = [
  { value: 'light', label: 'Light' }, { value: 'dark', label: 'Dark' },
  { value: 'win95', label: 'Win95' }, { value: 'pipboy', label: 'Pip-Boy' },
  { value: 'mirc', label: 'mIRC' }, { value: 'qbasic', label: 'QBasic' },
  { value: 'orange', label: 'Amber' }, { value: 'cga', label: 'CGA' },
  { value: 'atari', label: 'Atari 2600' }, { value: 'snes', label: 'SNES' },
  { value: 'bw_tv', label: 'B&W TV' },
];


const Sidebar: React.FC = () => {
  const { theme, setTheme } = useTheme();
  // Use the new context function
  const { openOrFocusFile } = useEditor(); // Get openOrFocusFile from context
  const [currentFolderPath, setCurrentFolderPath] = useState<string | null>(null);
  const [rootDirectoryEntries, setRootDirectoryEntries] = useState<DirectoryEntry[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [expandedFolders, setExpandedFolders] = useState<Record<string, boolean>>({});

  const handleOpenFolder = async () => {
    console.log('Requesting to open directory...');
    setError(null);
    setExpandedFolders({});
    try {
      const folderPath = await window.electronAPI.dialog_openDirectory();
      if (folderPath) {
        console.log(`Folder selected: ${folderPath}`);
        setCurrentFolderPath(folderPath);
      } else {
        console.log('Folder selection cancelled.');
      }
    } catch (err) {
      console.error('Error opening directory dialog:', err);
      setError('Failed to open directory dialog.');
    }
  };

  // Effect to read root directory
   useEffect(() => {
    if (currentFolderPath) {
      console.log(`Reading ROOT directory: ${currentFolderPath}`);
      setIsLoading(true);
      setError(null);
      setRootDirectoryEntries([]);
      setExpandedFolders({}); // Reset expanded state when root changes

      window.electronAPI.fs_readDirectory(currentFolderPath)
        .then(response => {
          if (response.success) {
            setRootDirectoryEntries(response.entries);
          } else {
            console.error('Failed to read directory:', response.error);
            setError(`Error reading directory: ${response.error}`);
          }
        })
        .catch(err => {
          console.error('IPC Error reading directory:', err);
          setError(`IPC Error: ${err.message || 'Unknown error'}`);
        })
        .finally(() => {
          setIsLoading(false);
        });
    } else {
      setRootDirectoryEntries([]);
    }
  }, [currentFolderPath]);


  const toggleFolderExpansion = useCallback((folderPath: string) => {
    setExpandedFolders(prev => ({
      ...prev,
      [folderPath]: !prev[folderPath],
    }));
  }, []);

  const handleGoUp = () => {
    if (currentFolderPath) {
        const parentPath = path.dirname(currentFolderPath);
        // Prevent going up from the root itself (e.g., '/')
        if (parentPath !== currentFolderPath) {
            console.log(`Navigating up to: ${parentPath}`);
            setCurrentFolderPath(parentPath);
            // No need to clear expandedFolders here, keep state if returning
        } else {
             console.log("Already at root, cannot go up further.");
        }
    }
  };

   // UPDATED: Use openOrFocusFile for files
   const handleEntryClick = useCallback((entry: DirectoryEntry) => {
    if (entry.isDirectory) {
      // Toggle expansion for directories
      toggleFolderExpansion(entry.path);
    } else {
      // Open or focus the file using the context function
      openOrFocusFile(entry.path).catch(err => {
          console.error("Error returned from openOrFocusFile call:", err);
          // Optionally show an error to the user
      });
    }
  }, [toggleFolderExpansion, openOrFocusFile]); // Use context function


  return (
    <div className="sidebar">
      {/* Header and Open Folder Button */}
      <div className="sidebar-header">
        <h2>Files</h2>
        {/* MODIFIED BUTTON: Icon only with title */}
        <button
          onClick={handleOpenFolder}
          title="Open Folder..." // Tooltip
          aria-label="Open Folder"
          // Use the generic icon-button class for styling
          className="open-folder-button icon-button"
        >
          <FaFolderOpen />
          {/* Removed the <span>Open...</span> text */}
        </button>
      </div>

      {/* Navigation Controls */}
      {currentFolderPath && (
        <div className="navigation-controls">
           {/* Up button remains the same */}
           <button
             onClick={handleGoUp}
             // Disable if parent is the same as current (e.g., at root '/')
             disabled={!currentFolderPath || path.dirname(currentFolderPath) === currentFolderPath}
             title="Go Up One Level"
             aria-label="Go Up One Level"
             className="up-button icon-button"
           >
             <FaLevelUpAlt />
           </button>
           <div className="current-folder-path" title={currentFolderPath}>
              <small>{currentFolderPath}</small>
           </div>
        </div>
      )}

      {/* File Tree Area */}
      <div className="file-tree">
          {/* Loading/Error/Placeholder/List remains the same */}
           {isLoading && <p>Loading...</p>}
           {error && <p className="error-message">Error: {error}</p>}
           {!isLoading && !error && rootDirectoryEntries.length === 0 && !currentFolderPath && (
             <p className="placeholder-message">Click the <FaFolderOpen style={{ verticalAlign: 'middle', margin: '0 2px'}} /> button above to browse files.</p>
           )}
           <ul>
             {rootDirectoryEntries.map((entry) => (
                <FileTreeNode
                  key={entry.path}
                  entry={entry}
                  isExpanded={!!expandedFolders[entry.path]}
                  allExpandedFolders={expandedFolders} // Pass the whole map down
                  onToggleExpand={toggleFolderExpansion} // Passed down for child nodes
                  onEntryClick={handleEntryClick} // Passed down for child nodes
                  level={0}
                />
             ))}
           </ul>
      </div>

      {/* Theme Switcher */}
      <div className="theme-switcher">
        {/* Theme switcher remains the same */}
        <label id="theme-select-label" htmlFor="theme-select">
          Theme:
        </label>
        <CustomSelect<ThemeName>
           labelId="theme-select-label"
           options={themeOptions}
           value={theme}
           onChange={(newTheme) => setTheme(newTheme)}
         />
       </div>
    </div>
  );
};

export default Sidebar;
// --- END FILE: src/renderer/components/Sidebar.tsx ---
--- END FILE: src/renderer/components/Sidebar.tsx ---

--- START FILE: src/renderer/components/TerminalTab.tsx ---
// --- START FILE: src/renderer/components/TerminalTab.tsx ---
import React, { useMemo } from 'react';
import { FaTimes, FaSpinner } from 'react-icons/fa'; // Close and Spinner icons
import './TabContainer.css'; // Reuse styles

interface TerminalTabProps {
    terminalId: string;
    title: string;
    isActive: boolean;
    isLoading: boolean;
    hasExited: boolean;
    onClick: (terminalId: string) => void;
    onClose: (terminalId: string) => void;
}

const TerminalTab = React.forwardRef<HTMLDivElement, TerminalTabProps>(({
    terminalId,
    title,
    isActive,
    isLoading,
    hasExited,
    onClick,
    onClose
}, ref) => {

    const handleCloseClick = (e: React.MouseEvent) => {
        e.stopPropagation(); // Prevent tab click when clicking close
        onClose(terminalId);
    };

    const handleClick = () => {
        if (!isActive) {
            onClick(terminalId);
        }
    };

    const displayTitle = useMemo(() => {
        if (isLoading) return "Loading...";
        if (hasExited) return `${title} (Exited)`;
        return title;
    }, [title, isLoading, hasExited]);

    return (
        <div
            ref={ref}
            className={`tab terminal-tab ${isActive ? 'active' : ''} ${hasExited ? 'exited' : ''} ${isLoading ? 'loading' : ''}`}
            onClick={handleClick}
            title={`Terminal: ${title} (ID: ${terminalId})${hasExited ? ' - Exited' : ''}`}
            role="tab"
            aria-selected={isActive}
        >
            {/* Maybe show spinner instead of close button when loading? */}
            {isLoading && <FaSpinner className="tab-loading-spinner spin-animation" />}

            <span className="tab-filename">{displayTitle}</span>

            {/* Don't show close button if loading */}
            {!isLoading && (
                 <button
                    className="tab-close-button"
                    onClick={handleCloseClick}
                    title="Close Terminal Tab"
                    aria-label={`Close ${title} terminal tab`}
                    type="button"
                    tabIndex={isActive ? 0 : -1}
                >
                    <FaTimes />
                </button>
            )}
        </div>
    );
});

TerminalTab.displayName = 'TerminalTab';
export default TerminalTab;
// --- END FILE: src/renderer/components/TerminalTab.tsx ---
--- END FILE: src/renderer/components/TerminalTab.tsx ---

--- START FILE: src/renderer/components/MainPanel.tsx ---
import React from 'react';
import { Allotment } from 'allotment';
import EditorPanel from './EditorPanel';
import TerminalPanel from './TerminalPanel';
import TabContainer from './TabContainer'; // Editor tabs
import TerminalTabContainer from './TerminalTabContainer'; // Terminal tabs
import { useTerminals } from '../contexts/TerminalContext'; // To get active terminal ID and list

// Helper function to get initial terminal size hint
const getTerminalInitialSize = (): number => {
    if (typeof window !== 'undefined' && typeof document !== 'undefined') {
      try {
        const heightValue = getComputedStyle(document.documentElement)
                              .getPropertyValue('--terminal-height')?.trim();
        if (heightValue) return parseInt(heightValue.replace('px', ''), 10) || 200;
      } catch (e) { /* ignore */ }
    }
    return 200;
};

const MainPanel: React.FC = () => {
    // Get the full list of terminals and the active ID
    const { openTerminals, activeTerminalId } = useTerminals();

    return (
        <div className="main-panel">
            {/* 1. Editor Tab Container */}
            <TabContainer />

            {/* 2. Allotment for Editor/Terminal Split */}
            <div style={{ flexGrow: 1, overflow: 'hidden' }}>
                <Allotment vertical>
                    {/* Editor Pane */}
                    <Allotment.Pane minSize={100}>
                        <EditorPanel />
                    </Allotment.Pane>

                    {/* Terminal Pane: Contains tabs AND ALL terminal instances */}
                    <Allotment.Pane
                        preferredSize={getTerminalInitialSize()}
                        minSize={50}
                        snap
                    >
                        <div className="terminal-area-container">
                            {/* Render Terminal Tabs */}
                            <TerminalTabContainer />

                            {/* Wrapper for ALL terminal panel instances */}
                            <div className="terminal-panels-wrapper">
                                {openTerminals.length === 0 && (
                                     <div className="terminal-placeholder">
                                         Click the '+' button to open a new terminal.
                                     </div>
                                )}
                                {openTerminals.map(terminal => (
                                    <div
                                        key={terminal.id} // Key on the wrapper div
                                        // Apply 'active' class conditionally for CSS visibility
                                        className={`terminal-panel-instance ${terminal.id === activeTerminalId ? 'active' : ''}`}
                                    >
                                        <TerminalPanel
                                            id={terminal.id}
                                            isActive={terminal.id === activeTerminalId}
                                        />
                                    </div>
                                ))}
                            </div>
                        </div>
                    </Allotment.Pane>
                </Allotment>
            </div>
        </div>
    );
};

export default MainPanel;
--- END FILE: src/renderer/components/MainPanel.tsx ---

--- START FILE: src/renderer/components/FileTreeNode.tsx ---
// --- START FILE: src/renderer/components/FileTreeNode.tsx ---
import React, { useState, useEffect, useCallback, memo } from 'react';
import {
    FaFolder, FaFolderOpen, FaFileAlt,
    FaChevronRight, FaChevronDown, FaSpinner // Added FaSpinner for loading
} from 'react-icons/fa';

import type { DirectoryEntry } from '../../shared.types';

interface FileTreeNodeProps {
    entry: DirectoryEntry;
    isExpanded: boolean;
    allExpandedFolders: Record<string, boolean>;
    onToggleExpand: (path: string) => void;
    onEntryClick: (entry: DirectoryEntry) => void;
    level: number;
}

const FileIcon: React.FC<{ isDirectory: boolean; isExpanded?: boolean }> = memo(({ isDirectory, isExpanded }) => {
    const icon = isDirectory
        ? (isExpanded ? <FaFolderOpen /> : <FaFolder />)
        : <FaFileAlt />;
    return <span className="file-icon">{icon}</span>;
});
FileIcon.displayName = 'FileIcon';

const ExpandIcon: React.FC<{ isExpanded: boolean }> = memo(({ isExpanded }) => {
    const icon = isExpanded ? <FaChevronDown /> : <FaChevronRight />;
    return <span className="expand-icon">{icon}</span>;
});
ExpandIcon.displayName = 'ExpandIcon';

// Loading Spinner Icon
const LoadingIcon: React.FC = memo(() => (
    <span className="loading-spinner">
        <FaSpinner className="spin-animation" /> {/* Apply animation via CSS */}
    </span>
));
LoadingIcon.displayName = 'LoadingIcon';


const FileTreeNode: React.FC<FileTreeNodeProps> = memo(({
    entry,
    isExpanded,
    allExpandedFolders,
    onToggleExpand,
    onEntryClick,
    level
}) => {
    const [children, setChildren] = useState<DirectoryEntry[]>([]);
    const [isLoading, setIsLoading] = useState<boolean>(false);
    const [error, setError] = useState<string | null>(null);
    // *** NEW STATE: Track if fetch has been attempted ***
    const [hasFetchedChildren, setHasFetchedChildren] = useState<boolean>(false);

    // Effect to fetch children
    useEffect(() => {
        // *** UPDATED CONDITION: Fetch only if not already fetched ***
        if (entry.isDirectory && isExpanded && !hasFetchedChildren && !isLoading) {
            console.log(`Node ${entry.name} [${entry.path}]: Expanding, fetching children (first time)...`);
            setIsLoading(true);
            setError(null);
            setChildren([]); // Clear any potential stale children data

            window.electronAPI.fs_readDirectory(entry.path)
                .then(response => {
                    if (response.success) {
                        setChildren(response.entries);
                        setError(null); // Clear any previous error
                    } else {
                        setError(response.error);
                        setChildren([]); // Ensure children are empty on error
                    }
                })
                .catch(err => {
                    setError(err.message || 'IPC Error');
                    setChildren([]); // Ensure children are empty on error
                })
                .finally(() => {
                    setIsLoading(false);
                    // *** Mark as fetched regardless of success/failure ***
                    setHasFetchedChildren(true);
                    console.log(`Node ${entry.name} [${entry.path}]: Fetch complete.`);
                });
        } else if (entry.isDirectory && !isExpanded && hasFetchedChildren) {
             // Optional: Reset fetch status if folder is collapsed, to allow refresh on re-expand
             // Comment this out if you want expansion to always show cached children after first load
             // console.log(`Node ${entry.name} [${entry.path}]: Collapsed, resetting fetch status.`);
             // setHasFetchedChildren(false);
             // setChildren([]); // Also clear children if resetting fetch status
        }
    }, [entry.isDirectory, entry.path, isExpanded, hasFetchedChildren, isLoading]); // Add hasFetchedChildren to dependencies


    const handleNodeClick = useCallback(() => {
        onEntryClick(entry);
    }, [onEntryClick, entry]);


    const indentStyle = { paddingLeft: `${level * 15}px` };

    return (
        <li className={`file-tree-node ${entry.isDirectory ? 'directory' : 'file'} ${isLoading ? 'loading' : ''}`}>
            <div
                className="node-content"
                style={indentStyle}
                onClick={handleNodeClick}
                title={entry.path}
            >
                {/* Render ExpandIcon, LoadingIcon, or spacer */}
                {entry.isDirectory ? (
                    <span className="toggle-icon">
                        {isLoading ? <LoadingIcon /> : <ExpandIcon isExpanded={isExpanded} />}
                    </span>
                ) : (
                    <span className="toggle-icon spacer"></span>
                )}

                <FileIcon isDirectory={entry.isDirectory} isExpanded={isExpanded} />
                <span className="node-name">{entry.name}</span>
            </div>

            {/* Render Children Recursively */}
            {entry.isDirectory && isExpanded && !isLoading && (
                <ul>
                    {error && <li className="error-message" style={{ paddingLeft: `${(level + 1) * 15}px` }}>Error: {error}</li>}
                    {/* *** ADDED CHECK: Show (empty) message only if fetched and empty *** */}
                    {children.length === 0 && !error && hasFetchedChildren && (
                        <li className="empty-folder-message" style={{ paddingLeft: `${(level + 1) * 15}px` }}>
                            <small><i>(empty)</i></small>
                        </li>
                    )}
                    {children.map(childEntry => (
                        <FileTreeNode
                            key={childEntry.path}
                            entry={childEntry}
                            isExpanded={!!allExpandedFolders[childEntry.path]}
                            allExpandedFolders={allExpandedFolders}
                            onToggleExpand={onToggleExpand}
                            onEntryClick={onEntryClick}
                            level={level + 1}
                        />
                    ))}
                </ul>
            )}
        </li>
    );
});

FileTreeNode.displayName = 'FileTreeNode';

export default FileTreeNode;
// --- END FILE: src/renderer/components/FileTreeNode.tsx ---
--- END FILE: src/renderer/components/FileTreeNode.tsx ---

--- START FILE: src/renderer/components/TabContainer.css ---
/* --- START FILE: src/renderer/components/TabContainer.css --- */
/* src/renderer/components/TabContainer.css */

.tab-container {
    display: flex;
    flex-wrap: nowrap;
    overflow-x: auto;
    overflow-y: hidden;
    background-color: var(--color-bg-sidebar);
    border-bottom: 1px solid var(--color-border);
    padding: var(--spacing-xxs) var(--spacing-xs) 0 var(--spacing-xs);
    flex-shrink: 0;
    /* --- ADJUSTED min-height --- */
    min-height: 24px; /* Reduce container min height */
    position: relative;

    scrollbar-width: thin;
    scrollbar-color: var(--scrollbar-thumb-bg) var(--scrollbar-track-bg);
}

/* Scrollbar Styling */
.tab-container::-webkit-scrollbar { height: 6px; }
.tab-container::-webkit-scrollbar-track { background: var(--scrollbar-track-bg); }
.tab-container::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb-bg); border-radius: 3px; }
.tab-container::-webkit-scrollbar-thumb:hover { background: color-mix(in srgb, var(--scrollbar-thumb-bg) 80%, black); }


.tab {
    display: flex;
    align-items: center;
    /* --- ADJUSTED vertical padding --- */
    padding: var(--spacing-xxs) var(--spacing-sm); /* Reduced top/bottom padding */
    border: 1px solid var(--color-border);
    border-bottom: none;
    background-color: var(--color-bg-button);
    color: var(--color-text-secondary);
    cursor: pointer;
    margin-right: var(--spacing-xxs);
    border-top-left-radius: var(--border-radius-sm);
    border-top-right-radius: var(--border-radius-sm);
    white-space: nowrap;
    position: relative;
    max-width: 200px;
    transition: background-color 0.15s ease, color 0.15s ease;
    z-index: 1;
    margin-bottom: -1px;
    /* --- ADJUSTED padding-bottom compensation --- */
    padding-bottom: calc(var(--spacing-xxs) + 1px); /* Use smaller variable here too */
    flex-shrink: 0;
}

.tab:hover {
    background-color: var(--color-bg-button-hover);
    color: var(--color-text-primary);
    z-index: 2;
}

.tab.active {
    background-color: var(--color-bg-editor);
    color: var(--color-text-primary);
    border-color: var(--color-border);
    border-bottom-color: var(--color-bg-editor);
    z-index: 3;
}

/* Active TERMINAL tabs override */
.terminal-tab-container .tab.active {
     background-color: var(--color-bg-terminal);
     border-bottom-color: var(--color-bg-terminal);
}


.tab-filename {
    overflow: hidden;
    text-overflow: ellipsis;
    margin-right: var(--spacing-sm);
    font-size: var(--font-size-sm); /* Keep font size unless too cramped */
    line-height: 1.2; /* Adjust line-height slightly if needed */
}

.tab-dirty-indicator {
    color: var(--color-text-accent);
    font-size: 8px; /* Make indicator smaller */
    margin-right: 2px; /* Reduce margin slightly */
    line-height: 1;
}

.tab-close-button {
    background: none;
    border: none;
    color: var(--color-text-tertiary);
    padding: 0;
    margin-left: auto;
    cursor: pointer;
    /* --- ADJUSTED size/font-size --- */
    font-size: 0.7em; /* Make icon even smaller */
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    width: 14px;  /* Reduce size */
    height: 14px; /* Reduce size */
    line-height: 14px; /* Match height */
    flex-shrink: 0;
    transition: background-color 0.1s ease, color 0.1s ease;
}

.tab-close-button:hover {
    background-color: var(--color-bg-hover);
    color: var(--color-text-error);
}

.tab.active .tab-close-button {
    color: var(--color-text-secondary);
}
.tab.active .tab-close-button:hover {
    background-color: var(--color-bg-hover);
    color: var(--color-text-error);
}

/* Style for Terminal Tabs specifically if needed */
.terminal-tab { /* Inherits .tab styles */ }

/* Style for exited/loading states on terminal tabs */
.terminal-tab.exited { opacity: 0.7; font-style: italic; }
.terminal-tab.loading { opacity: 0.8; cursor: default; }
.tab-loading-spinner { margin-right: var(--spacing-xs); font-size: 0.8em; /* Smaller spinner */ }

/* Add Tab Button */
.add-tab-button {
    /* Inherits .icon-button styles */
    margin-left: var(--spacing-xs);
    position: relative;
    top: 1px;
    /* --- ADJUSTED padding/font-size --- */
    padding: 2px; /* Smaller padding */
    font-size: 0.8em; /* Smaller icon */
    align-self: center;
    margin-bottom: var(--spacing-xxs);
}

/* Win95/mIRC specific overrides - Also adjust padding */
.theme-win95 .tab-container,
.theme-mirc .tab-container {
    background-color: var(--color-bg-app);
    padding-left: 0;
    padding-right: 0;
    border-bottom: none;
}
.theme-win95 .tab,
.theme-mirc .tab {
    border-radius: 0;
    border: none;
     box-shadow: inset -1px 0px var(--win95-bevel-shadow-dark, transparent),
                 inset 1px 1px var(--win95-bevel-shadow-light, transparent),
                 inset 0px -1px var(--win95-bevel-shadow-darker, transparent);
    background-color: var(--color-bg-button);
    color: var(--color-text-button);
    margin-right: 0;
    margin-bottom: 0;
    /* --- ADJUSTED padding --- */
    padding-bottom: var(--spacing-xxs); /* Match new base vertical padding */
    padding-top: calc(var(--spacing-xxs) + 1px); /* Adjust for bevel */
    border-bottom: 1px solid var(--win95-bevel-shadow-darker);
}
.theme-win95 .tab.active,
.theme-mirc .tab.active {
    box-shadow: inset -1px 0px var(--win95-bevel-shadow-dark, transparent),
                inset 1px 1px var(--win95-bevel-shadow-light, transparent);
    color: var(--color-text-primary);
    border-bottom-color: transparent;
    position: relative;
    z-index: 3;
    margin-bottom: -1px;
    /* --- ADJUSTED padding --- */
    padding-bottom: calc(var(--spacing-xxs) + 1px); /* Add back padding */
}
/* Win95/mIRC Active Tab Backgrounds (No change needed here) */
.theme-win95 .tab.active, .theme-mirc .tab.active { background-color: var(--color-bg-editor); }
.theme-win95 .terminal-tab-container .tab.active, .theme-mirc .terminal-tab-container .tab.active { background-color: var(--color-bg-terminal); }

.theme-win95 .tab-close-button,
.theme-mirc .tab-close-button {
    color: var(--color-text-button);
    font-family: system-ui, sans-serif;
    /* --- ADJUSTED size/padding --- */
    font-size: 0.8em; /* Slightly smaller */
    width: auto; height: auto; border-radius: 0;
    background: transparent;
    box-shadow: none;
    line-height: 1;
    padding: 0px 2px; /* Minimal padding */
}
.theme-win95 .tab-close-button:hover,
.theme-mirc .tab-close-button:hover {
    background-color: transparent;
    color: var(--color-text-error);
}

.theme-win95 .add-tab-button,
.theme-mirc .add-tab-button {
    box-shadow: none;
    top: 0px;
    margin-bottom: 0px;
}


/* --- END FILE: src/renderer/components/TabContainer.css --- */
--- END FILE: src/renderer/components/TabContainer.css ---

--- START FILE: src/renderer/components/CommandPalette.css ---
/* --- START FILE: src/renderer/components/CommandPalette.css --- */
/* src/renderer/components/CommandPalette.css */

.command-palette-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 10vh;
    z-index: 1000;
}

.command-palette-container {
    background-color: var(--color-bg-sidebar);
    color: var(--color-text-primary);
    border: 1px solid var(--color-border-accent);
    border-radius: var(--border-radius-md);
    box-shadow: var(--box-shadow-md);
    width: 90%;
    max-width: 600px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.command-palette-input {
    width: 100%;
    padding: var(--spacing-sm) var(--spacing-md);
    font-size: var(--font-size-lg);
    border: none;
    border-bottom: 1px solid var(--color-border);
    background-color: var(--color-bg-input);
    color: var(--color-text-primary);
    box-sizing: border-box;
}

.command-palette-input:focus {
    outline: none;
    border-bottom-color: var(--color-border-focus);
    box-shadow: 0 1px 0 0 var(--color-border-focus);
}

.command-palette-list {
    list-style: none;
    padding: 0;
    margin: 0;
    max-height: 60vh;
    overflow-y: auto;
    flex-grow: 1;
    scrollbar-width: thin;
    scrollbar-color: var(--scrollbar-thumb-bg) var(--scrollbar-track-bg);
}

/* Scrollbar Styling */
.command-palette-list::-webkit-scrollbar { width: 8px; }
.command-palette-list::-webkit-scrollbar-track { background: var(--scrollbar-track-bg); }
.command-palette-list::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb-bg); border-radius: 4px; }
.command-palette-list::-webkit-scrollbar-thumb:hover { background: color-mix(in srgb, var(--scrollbar-thumb-bg) 80%, black); }


.command-palette-item {
    padding: var(--spacing-xs) var(--spacing-md);
    cursor: pointer;
    border-bottom: 1px solid var(--color-border);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    /* Use Flexbox for icon alignment */
    display: flex;
    align-items: center;
    gap: var(--spacing-sm); /* Space between icon and label */
}
.command-palette-item:last-child {
    border-bottom: none;
}

.command-palette-item:hover {
    background-color: var(--color-bg-hover);
}

.command-palette-item.selected {
    background-color: var(--color-bg-selected);
    color: var(--color-text-inverse);
}
/* Ensure icon color matches selected text color */
.command-palette-item.selected .command-palette-icon {
    color: var(--color-text-inverse);
}


.command-palette-item.no-results {
    font-style: italic;
    color: var(--color-text-tertiary);
    cursor: default;
    justify-content: center; /* Center the no results text */
}
.command-palette-item.no-results:hover,
.command-palette-item.no-results.selected {
    background-color: transparent;
    color: var(--color-text-tertiary);
}

/* Icon Styling */
.command-palette-icon {
    font-size: 1em; /* Match text size or adjust slightly */
    color: var(--color-text-secondary); /* Use secondary color */
    flex-shrink: 0; /* Prevent icon from shrinking */
    width: 1.2em; /* Give icon a consistent width */
    text-align: center;
}

.command-palette-label {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}


/* --- Theme Specific Overrides --- */

/* Win95/mIRC Specifics */
.theme-win95 .command-palette-container,
.theme-mirc .command-palette-container {
    border: none;
    border-radius: 0;
    box-shadow: inset 1px 1px var(--win95-bevel-shadow-dark, transparent),
                inset -1px -1px var(--win95-bevel-shadow-light, transparent),
                1px 1px 0 1px var(--win95-bevel-shadow-darker, transparent),
                -1px -1px 0 1px var(--win95-bevel-shadow-lighter, transparent);
}
.theme-win95 .command-palette-input,
.theme-mirc .command-palette-input {
    border-radius: 0;
    border-bottom: none;
     box-shadow: inset 1px 1px var(--win95-bevel-shadow-dark, transparent),
                inset -1px -1px var(--win95-bevel-shadow-light, transparent);
    margin: 2px;
    width: calc(100% - 4px);
}
.theme-win95 .command-palette-input:focus,
.theme-mirc .command-palette-input:focus {
    box-shadow: inset 1px 1px var(--win95-bevel-shadow-dark, transparent),
                inset -1px -1px var(--win95-bevel-shadow-light, transparent);
}
.theme-win95 .command-palette-list,
.theme-mirc .command-palette-list {
    margin: 0 2px 2px 2px;
}
.theme-win95 .command-palette-item,
.theme-mirc .command-palette-item {
     border-bottom: 1px solid var(--color-border);
}
.theme-win95 .command-palette-item.selected,
.theme-mirc .command-palette-item.selected {
    background-color: var(--color-bg-selected);
    color: var(--color-text-inverse);
}
.theme-win95 .command-palette-item.selected .command-palette-icon,
.theme-mirc .command-palette-item.selected .command-palette-icon {
    color: var(--color-text-inverse);
}
.theme-win95 .command-palette-icon,
.theme-mirc .command-palette-icon {
    color: var(--color-text-secondary);
}


/* Pip-Boy Specifics */
.theme-pipboy .command-palette-container {
    border-color: var(--pipboy-green);
    background-color: var(--pipboy-bg);
}
.theme-pipboy .command-palette-input {
    background-color: var(--pipboy-bg-lighter);
    border-bottom-color: var(--pipboy-green-dark);
    color: var(--pipboy-green);
}
.theme-pipboy .command-palette-input:focus {
    border-bottom-color: var(--pipboy-green);
    box-shadow: 0 1px 0 0 var(--pipboy-green);
}
.theme-pipboy .command-palette-item {
     border-bottom-color: var(--pipboy-green-dark);
     color: var(--pipboy-green);
}
.theme-pipboy .command-palette-item:hover {
     background-color: var(--pipboy-green-darker);
}
.theme-pipboy .command-palette-item.selected {
    background-color: var(--pipboy-green-dark);
    color: var(--pipboy-bg);
}
.theme-pipboy .command-palette-icon {
    color: var(--pipboy-green);
}
.theme-pipboy .command-palette-item.selected .command-palette-icon {
    color: var(--pipboy-bg);
}
/* --- END FILE: src/renderer/components/CommandPalette.css --- */
--- END FILE: src/renderer/components/CommandPalette.css ---

--- START FILE: src/renderer/components/EditorPanel.tsx ---
// --- START FILE: src/renderer/components/EditorPanel.tsx ---
import React, { useEffect, useRef, useCallback, useMemo } from 'react';
import MonacoEditor from 'react-monaco-editor';
import * as monaco from 'monaco-editor/esm/vs/editor/editor.api';
import { useTheme, ThemeName } from '../contexts/ThemeContext';
import { useEditor } from '../contexts/EditorContext';

// Helper function to safely get and parse font size from CSS variable
const getEditorFontSize = (): number => {
    if (typeof document === 'undefined') return 13;
    try {
        const fontSizeValue = getComputedStyle(document.documentElement).getPropertyValue('--font-size-editor');
        return parseInt(fontSizeValue?.replace('px', '').trim() || '13', 10);
    } catch (e) {
        console.warn("Could not get computed style for font size, using default.", e);
        return 13;
    }
};

// Helper to get computed CSS variable value
const getCssVar = (varName: string, fallback: string): string => {
    if (typeof document !== 'undefined') {
         try {
             return getComputedStyle(document.documentElement).getPropertyValue(varName)?.trim() || fallback;
         } catch(e) {
              console.warn(`Could not get computed style for CSS var ${varName}, using fallback.`, e);
              return fallback;
         }
    }
    return fallback;
};

// Language Mapping Utility
const getLanguageFromPath = (filePath: string | null): string => {
    if (!filePath) return 'plaintext';
    const extension = filePath.split('.').pop()?.toLowerCase();
    // Add more mappings as needed
    switch (extension) {
        case 'js': case 'jsx': return 'javascript';
        case 'ts': case 'tsx': return 'typescript';
        case 'json': return 'json';
        case 'css': return 'css';
        case 'html': case 'htm': return 'html';
        case 'md': case 'markdown': return 'markdown';
        case 'py': return 'python';
        case 'java': return 'java';
        case 'c': case 'h': return 'c';
        case 'cpp': case 'hpp': return 'cpp';
        case 'cs': return 'csharp';
        case 'sh': return 'shell';
        case 'xml': return 'xml';
        case 'yaml': case 'yml': return 'yaml';
        case 'sql': return 'sql';
        default: return 'plaintext';
    }
};


const EditorPanel: React.FC = () => {
    const { theme } = useTheme();
    const {
        activeFilePath,
        getActiveFile,
        updateActiveFileDirtyState, // <-- Function to call
        saveActiveFile,
        setCursorPosition,
    } = useEditor();

    const editorRef = useRef<monaco.editor.IStandaloneCodeEditor | null>(null);
    const monacoRef = useRef<typeof monaco | null>(null);
    const lastSetModelPath = useRef<string | null>(null);
    const changeListenerDisposable = useRef<monaco.IDisposable | null>(null);
    const cursorListenerDisposable = useRef<monaco.IDisposable | null>(null);
    const viewStateCache = useRef<Map<string, monaco.editor.ICodeEditorViewState | null>>(new Map());

    const activeFile = useMemo(() => getActiveFile(), [getActiveFile]);

    const getMonacoThemeName = useCallback((currentTheme: ThemeName): string => {
        switch (currentTheme) {
            case 'light': return 'vs';
            case 'dark': return 'vs-dark';
            // ... other themes
            case 'win95': return 'win95-monaco-theme';
            case 'pipboy': return 'pipboy-monaco-theme';
            case 'mirc': return 'mirc-monaco-theme';
            case 'qbasic': return 'qbasic-monaco-theme';
            case 'orange': return 'orange-monaco-theme';
            case 'cga': return 'cga-monaco-theme';
            case 'atari': return 'atari-monaco-theme';
            case 'snes': return 'snes-monaco-theme';
            case 'bw_tv': return 'bw-tv-monaco-theme';
            default: return 'vs-dark';
        }
    }, []);

    const editorOptions = useMemo((): monaco.editor.IStandaloneEditorConstructionOptions => ({
        selectOnLineNumbers: true,
        automaticLayout: true,
        fontFamily: 'var(--font-family-mono)',
        fontSize: getEditorFontSize(),
        minimap: { enabled: true },
        wordWrap: 'on',
        scrollBeyondLastLine: false,
        readOnly: activeFile?.isLoading ?? !activeFile,
    }), [activeFile]);


    // --- Editor Change Handler ---
    // MODIFIED: Always call context function, pass current editor value
    const handleInternalChange = useCallback(() => {
        const editor = editorRef.current;
        const currentModelValue = editor?.getValue();

        if (editor && currentModelValue !== undefined) {
            // Pass the current editor value to the context function
            // Let the context handle the comparison with its latest state
             console.log(`[EditorPanel -> handleInternalChange] Calling updateActiveFileDirtyState with current editor content (length: ${currentModelValue.length})`);
            updateActiveFileDirtyState(currentModelValue);
        }
    }, [updateActiveFileDirtyState]); // Depends only on the context function


    // --- Editor Mount Logic ---
    const editorDidMount = useCallback((
        editor: monaco.editor.IStandaloneCodeEditor,
        monacoInstance: typeof monaco
    ) => {
        console.log('Editor mounted!');
        editorRef.current = editor;
        monacoRef.current = monacoInstance;
        lastSetModelPath.current = null;
        viewStateCache.current.clear();

        changeListenerDisposable.current?.dispose();
        cursorListenerDisposable.current?.dispose();

        // Define custom themes (No changes needed here, keep as is)
        const defineTheme = (name: string, base: 'vs' | 'vs-dark', cssVarPrefix: string, colorsOverride?: monaco.editor.IStandaloneThemeData['colors']) => {
             try {
                 monacoInstance.editor.defineTheme(name, {
                    base: base,
                    inherit: true,
                    rules: [],
                    colors: {
                        'editor.background': getCssVar(`--${cssVarPrefix}-bg`, base === 'vs' ? '#ffffff' : '#1e1e1e'),
                        'editor.foreground': getCssVar(`--${cssVarPrefix}-text`, base === 'vs' ? '#000000' : '#d4d4d4'),
                        'editorCursor.foreground': getCssVar(`--${cssVarPrefix}-accent`, base === 'vs' ? '#000000' : '#aeafad'),
                        'editorLineNumber.foreground': getCssVar(`--${cssVarPrefix}-tertiary`, '#858585'),
                        'editorLineNumber.activeForeground': getCssVar(`--${cssVarPrefix}-secondary`, '#c6c6c6'),
                        'editor.selectionBackground': getCssVar(`--${cssVarPrefix}-selected-bg`, '#add6ff'),
                        'editor.selectionForeground': getCssVar(`--${cssVarPrefix}-selected-text`, '#000000'),
                        'editorWidget.background': getCssVar(`--${cssVarPrefix}-widget-bg`, base === 'vs' ? '#f3f3f3' : '#252526'),
                        'editorWidget.border': getCssVar(`--${cssVarPrefix}-border`, '#c8c8c8'),
                        'input.background': getCssVar(`--${cssVarPrefix}-input-bg`, base === 'vs' ? '#ffffff' : '#3c3c3c'),
                        'input.foreground': getCssVar(`--${cssVarPrefix}-input-text`, base === 'vs' ? '#000000' : '#d4d4d4'),
                        'input.border': getCssVar(`--${cssVarPrefix}-input-border`, '#bebebe'),
                        // Theme-specific overrides
                         ...(name === 'win95-monaco-theme' && { 'editor.selectionForeground': getCssVar('--color-text-inverse', '#ffffff') }),
                         ...(name === 'mirc-monaco-theme' && { 'editor.selectionForeground': getCssVar('--color-text-inverse', '#ffffff') }),
                         ...(name === 'pipboy-monaco-theme' && { 'editor.selectionForeground': getCssVar('--pipboy-bg', '#0a1a0f') }),
                         ...(name === 'qbasic-monaco-theme' && { 'editor.selectionForeground': getCssVar('--qbasic-white', '#FFFFFF') }),
                         ...(name === 'orange-monaco-theme' && { 'editor.selectionForeground': getCssVar('--orange-dark', '#201500') }),
                         ...(name === 'cga-monaco-theme' && { 'editor.selectionForeground': getCssVar('--cga-black', '#000000') }),
                         ...(name === 'atari-monaco-theme' && { 'editor.selectionForeground': getCssVar('--atari-black', '#000000') }),
                         ...(name === 'snes-monaco-theme' && { 'editor.selectionForeground': getCssVar('--snes-bg', '#2F2F4F') }),
                         ...(name === 'bw-tv-monaco-theme' && { 'editor.selectionForeground': getCssVar('--bw-black', '#000000') }),
                        ...colorsOverride
                    }
                 });
             } catch (error) { console.error(`Failed to define Monaco theme '${name}':`, error); }
         };
        // Define all themes...
        defineTheme('pipboy-monaco-theme', 'vs-dark', 'pipboy', { 'editor.background': getCssVar('--pipboy-bg', '#0a1a0f'), 'editor.foreground': getCssVar('--pipboy-green', '#15ff60'), 'editorCursor.foreground': getCssVar('--pipboy-green', '#15ff60'), 'editor.selectionBackground': getCssVar('--pipboy-green-dark', '#10b445'), 'editorWidget.background': getCssVar('--pipboy-bg-lighter', '#102a18'), 'editorWidget.border': getCssVar('--pipboy-green-dark', '#10b445'), });
        defineTheme('win95-monaco-theme', 'vs', 'win95', { 'editor.background': getCssVar('--color-bg-editor', '#ffffff'), 'editor.foreground': getCssVar('--color-text-primary', '#000000'), 'editorCursor.foreground': '#000000', 'editor.selectionBackground': getCssVar('--color-bg-selected', '#000080'), });
        defineTheme('mirc-monaco-theme', 'vs', 'mirc', { 'editor.background': getCssVar('--color-bg-editor', '#ffffff'), 'editor.foreground': getCssVar('--color-text-primary', '#000000'), 'editorCursor.foreground': '#000000', 'editor.selectionBackground': getCssVar('--color-bg-selected', '#000080'), });
        defineTheme('qbasic-monaco-theme', 'vs-dark', 'qbasic', { 'editor.background': getCssVar('--qbasic-blue', '#0000AA'), 'editor.foreground': getCssVar('--qbasic-yellow', '#FFFF55'), 'editorCursor.foreground': getCssVar('--qbasic-white', '#FFFFFF'), 'editor.selectionBackground': getCssVar('--qbasic-dark-gray', '#555555'), });
        defineTheme('orange-monaco-theme', 'vs-dark', 'orange', { 'editor.background': getCssVar('--orange-dark', '#201500'), 'editor.foreground': getCssVar('--orange-bright', '#FFA500'), 'editorCursor.foreground': getCssVar('--orange-bright', '#FFA500'), 'editor.selectionBackground': getCssVar('--orange-medium', '#D98C00'), });
        defineTheme('cga-monaco-theme', 'vs-dark', 'cga', { 'editor.background': getCssVar('--cga-black', '#000000'), 'editor.foreground': getCssVar('--cga-cyan', '#55FFFF'), 'editorCursor.foreground': getCssVar('--cga-white', '#FFFFFF'), 'editor.selectionBackground': getCssVar('--cga-cyan', '#55FFFF'), });
        defineTheme('atari-monaco-theme', 'vs-dark', 'atari', { 'editor.background': getCssVar('--atari-black', '#000000'), 'editor.foreground': getCssVar('--atari-cyan', '#3FFFCF'), 'editorCursor.foreground': getCssVar('--atari-orange', '#D87050'), 'editor.selectionBackground': getCssVar('--atari-orange', '#D87050'), });
        defineTheme('snes-monaco-theme', 'vs-dark', 'snes', { 'editor.background': getCssVar('--snes-bg', '#2F2F4F'), 'editor.foreground': getCssVar('--snes-text', '#E0E0FF'), 'editorCursor.foreground': getCssVar('--snes-accent4', '#E0E040'), 'editor.selectionBackground': getCssVar('--snes-accent1', '#8080FF'), });
        defineTheme('bw-tv-monaco-theme', 'vs-dark', 'bw-tv', { 'editor.background': getCssVar('--bw-black', '#000000'), 'editor.foreground': getCssVar('--bw-light-gray', '#cccccc'), 'editorCursor.foreground': getCssVar('--bw-white', '#ffffff'), 'editor.selectionBackground': getCssVar('--bw-light-gray', '#cccccc'), });

        monacoInstance.editor.setTheme(getMonacoThemeName(theme));
        editor.updateOptions({ fontSize: getEditorFontSize() });

        const initialActiveFile = getActiveFile();
        if (initialActiveFile && initialActiveFile.content !== null) {
            console.log(`EditorDidMount: Setting initial model value for ${initialActiveFile.path}`);
            editor.setValue(initialActiveFile.content);
            lastSetModelPath.current = initialActiveFile.path;
            monacoInstance.editor.setModelLanguage(editor.getModel()!, getLanguageFromPath(initialActiveFile.path));
            const initialPosition = editor.getPosition();
            if (initialPosition) setCursorPosition(initialPosition);
        } else {
            editor.setValue('// Open a file from the sidebar...');
            lastSetModelPath.current = null;
            monacoInstance.editor.setModelLanguage(editor.getModel()!, 'plaintext');
            setCursorPosition(null);
        }
        editor.getModel()?.pushStackElement();

        // Attach the onChange listener - calls the MODIFIED handler
        changeListenerDisposable.current = editor.onDidChangeModelContent(() => {
            handleInternalChange(); // This now calls the context function
        });
        console.log("EditorDidMount: Attached onDidChangeModelContent listener.");

        cursorListenerDisposable.current = editor.onDidChangeCursorPosition((e) => {
            if (e.position) setCursorPosition(e.position);
            else setCursorPosition(null);
        });
        console.log("EditorDidMount: Attached onDidChangeCursorPosition listener.");

        // Add Ctrl+S Command (No change here, relies on context save function)
        editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KeyS, () => {
            console.log(`[Ctrl+S Handler] Triggered.`);
            const currentContent = editorRef.current?.getValue();
            const activeFileNow = getActiveFile(); // Still useful to check *if* there's an active file

            console.log(`[Ctrl+S Handler] Content to save (length: ${currentContent?.length ?? 'undefined'}):`, currentContent?.substring(0, 50) + '...');

            if (activeFileNow && currentContent !== undefined) {
                 // We no longer log dirty state here, context handles it
                 console.log(`[Ctrl+S Handler] Active file: ${activeFileNow.path}. Calling saveActiveFile...`);
                 saveActiveFile(currentContent)
                    .then(() => {
                        console.log(`[Ctrl+S Handler] saveActiveFile promise resolved (may or may not indicate success) for ${activeFileNow.path}.`);
                    })
                    .catch(err => {
                        console.error(`[Ctrl+S Handler] Error during save operation for ${activeFileNow.path}:`, err);
                    });
            } else {
                console.log(`[Ctrl+S Handler] No active file or content unavailable. Cannot save.`);
            }
         });

        editor.focus();

        return () => {
             console.log("Editor unmounting, disposing listeners.");
             changeListenerDisposable.current?.dispose();
             cursorListenerDisposable.current?.dispose();
             changeListenerDisposable.current = null;
             cursorListenerDisposable.current = null;
             editorRef.current = null;
             monacoRef.current = null;
        };
    }, [theme, getMonacoThemeName, getActiveFile, handleInternalChange, saveActiveFile, updateActiveFileDirtyState, setCursorPosition]);


    // --- Effect to UPDATE editor content when ACTIVE file changes ---
    useEffect(() => {
        const editor = editorRef.current;
        const monaco = monacoRef.current;

        const previousPath = lastSetModelPath.current;
        if (editor && previousPath && previousPath !== activeFile?.path) {
            const currentState = editor.saveViewState();
            viewStateCache.current.set(previousPath, currentState);
            console.log(`Saved view state for ${previousPath}`);
        }

        if (!editor || !monaco ) {
             console.log("Editor not ready, skipping active file update.");
             return;
        }

        if (!activeFile) {
            if (lastSetModelPath.current !== null) {
                console.log("No active file, clearing editor.");
                editor.setValue('');
                lastSetModelPath.current = null;
                monaco.editor.setModelLanguage(editor.getModel()!, 'plaintext');
                editor.updateOptions({ readOnly: true });
                setCursorPosition(null);
            }
            return;
        }

        // *** IMPORTANT: Check activeFile.content specifically ***
        // Check if path changed AND the content in the context is NOT null (meaning load is complete)
        // AND the file isn't currently marked as loading
        if (activeFile.path !== lastSetModelPath.current && activeFile.content !== null && !activeFile.isLoading) {
            console.log(`Active file changed to ${activeFile.path} AND content/loading state is ready. Updating editor model.`);

            editor.setValue(activeFile.content);
            lastSetModelPath.current = activeFile.path;

             const previousViewState = viewStateCache.current.get(activeFile.path);
             if (previousViewState) {
                 console.log(`Restoring view state for ${activeFile.path}`);
                 editor.restoreViewState(previousViewState);
             } else {
                  console.log(`No view state found for ${activeFile.path}, using default.`);
                  editor.setScrollPosition({ scrollTop: 0, scrollLeft: 0 });
                  editor.setPosition({ lineNumber: 1, column: 1 });
             }

             const currentPosition = editor.getPosition();
             if (currentPosition) setCursorPosition(currentPosition);

             const newLanguage = getLanguageFromPath(activeFile.path);
             const model = editor.getModel();
             if (model && model.getLanguageId() !== newLanguage) {
                 monaco.editor.setModelLanguage(model, newLanguage);
                 console.log(`Editor language set to: ${newLanguage}`);
             }

             editor.focus();
        } else if (activeFile.path === lastSetModelPath.current) {
             console.log(`Active file path ${activeFile.path} hasn't changed, skipping model update.`);
        } else {
             console.log(`Active file changed to ${activeFile.path} BUT content is null or still loading. Deferring editor model update.`);
        }


        // Always update readOnly state based on latest activeFile status
        const shouldBeReadOnly = activeFile.isLoading || !activeFile.path; // Consider no path as readonly too
        if (editor.getOption(monaco.editor.EditorOption.readOnly) !== shouldBeReadOnly) {
             console.log(`Updating editor readOnly state to: ${shouldBeReadOnly}`);
             editor.updateOptions({ readOnly: shouldBeReadOnly });
        }

    }, [activeFile, setCursorPosition]);


    // Effect to update theme and font size
    useEffect(() => {
        const editor = editorRef.current;
        const monaco = monacoRef.current;
        if (editor && monaco) {
            monaco.editor.setTheme(getMonacoThemeName(theme));
            editor.updateOptions({ fontSize: getEditorFontSize() });
        }
    }, [theme, getMonacoThemeName]);


    return (
        <div className="editor-panel" id="editor-panel-main">
            {activeFile?.error && <div className="editor-context-error">Error: {activeFile.error}</div>}
            {activeFile?.isLoading && <div className="editor-loading-indicator">Loading...</div>}

            <MonacoEditor
                key={activeFilePath || 'no-file'}
                width="100%"
                height="100%"
                language={getLanguageFromPath(activeFilePath)}
                theme={getMonacoThemeName(theme)}
                options={editorOptions}
                // Value is primarily controlled by the useEffect hook reacting to activeFile
                value={activeFile?.content ?? ''} // Provide default empty string
                // onChange is technically optional now as we use the internal listener
                // onChange={handleInternalChange} // This would call the *new* handleInternalChange
                editorDidMount={editorDidMount}
            />
        </div>
    );
};

export default EditorPanel;
// --- END FILE: src/renderer/components/EditorPanel.tsx ---
--- END FILE: src/renderer/components/EditorPanel.tsx ---

--- START FILE: src/renderer/components/CustomSelect.css ---
/* src/renderer/components/CustomSelect.css */

.custom-select-container {
    position: relative; /* Anchor for the absolute positioned options */
    width: 100%;
    font-family: var(--font-family-ui);
  }
  
  .custom-select-trigger {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: var(--spacing-xs) var(--spacing-sm);
    background-color: var(--color-bg-input);
    color: var(--color-text-primary);
    border: 1px solid var(--color-border-input);
    border-radius: var(--border-radius-sm);
    font-size: var(--font-size-sm);
    cursor: pointer;
    text-align: left;
    appearance: none; /* Remove default button styles */
  }
  
  .custom-select-trigger:focus {
    outline: none;
    border-color: var(--color-border-focus);
    box-shadow: 0 0 0 1px var(--color-border-focus);
  }
  
  .custom-select-arrow {
    margin-left: var(--spacing-sm);
    color: var(--color-text-secondary);
  }
  
  .custom-select-options {
    position: absolute;
    /* Position it above the trigger */
    bottom: calc(100% + var(--spacing-xxs)); /* Place it just above, with a small gap */
    left: 0;
    right: 0; /* Make it full width */
    background-color: var(--color-bg-dropdown);
    border: 1px solid var(--color-border-input);
    border-radius: var(--border-radius-sm);
    list-style: none;
    padding: var(--spacing-xs) 0;
    margin: 0;
    max-height: 150px; /* Limit height and allow scrolling */
    overflow-y: auto;
    z-index: 10; /* Ensure it appears above other elements */
    box-shadow: var(--box-shadow-sm);
  }
  
  .custom-select-option {
    padding: var(--spacing-xs) var(--spacing-sm);
    cursor: pointer;
    color: var(--color-text-primary);
    font-size: var(--font-size-sm);
  }
  
  .custom-select-option:hover {
    background-color: var(--color-bg-hover);
  }
  
  .custom-select-option.selected {
    background-color: var(--color-bg-selected);
    color: var(--color-text-inverse); /* Adjust if needed based on selection bg */
    font-weight: bold; /* Or other indicator */
  }
  
  /* Optional: Style scrollbar inside options */
  .custom-select-options::-webkit-scrollbar {
    width: 8px;
  }
  .custom-select-options::-webkit-scrollbar-track {
    background: var(--scrollbar-track-bg);
    border-radius: 4px;
  }
  .custom-select-options::-webkit-scrollbar-thumb {
    background: var(--scrollbar-thumb-bg);
    border-radius: 4px;
  }
  .custom-select-options::-webkit-scrollbar-thumb:hover {
    background: color-mix(in srgb, var(--scrollbar-thumb-bg) 80%, black);
  }
--- END FILE: src/renderer/components/CustomSelect.css ---

--- START FILE: src/renderer/components/CommandPalette.tsx ---
// --- START FILE: src/renderer/components/CommandPalette.tsx ---
import React, { useState, useEffect, useRef, useCallback, useMemo, ComponentType } from 'react'; // Import ComponentType
import { useTheme, ThemeName } from '../contexts/ThemeContext';
import { useTerminals } from '../contexts/TerminalContext';
// --- Icon Imports ---
import {
    FaPalette, FaTerminal, FaFolderOpen, FaSignOutAlt, FaTools, FaExpandAlt,
    FaMinusSquare, FaPlusSquare, FaRedo // Removed FaFont, Added specific icons
} from 'react-icons/fa';
// Import other icons as needed
import './CommandPalette.css';

interface Command {
    id: string;
    label: string;
    execute: () => void | Promise<void>;
    icon?: ComponentType<{ className?: string }>; // Optional icon component type
}

interface CommandPaletteProps {
    isOpen: boolean;
    onClose: () => void;
}

// Define theme options statically here if not exported from context
const availableThemes: { value: ThemeName; label: string }[] = [
    { value: 'light', label: 'Light' }, { value: 'dark', label: 'Dark' },
    { value: 'win95', label: 'Win95' }, { value: 'pipboy', label: 'Pip-Boy' },
    { value: 'mirc', label: 'mIRC' }, { value: 'qbasic', label: 'QBasic' },
    { value: 'orange', label: 'Amber' }, { value: 'cga', label: 'CGA' },
    { value: 'atari', label: 'Atari 2600' }, { value: 'snes', label: 'SNES' },
    { value: 'bw_tv', label: 'B&W TV' },
];

const CommandPalette: React.FC<CommandPaletteProps> = ({ isOpen, onClose }) => {
    // Add fontSize functions from context
    const { setTheme, increaseFontSize, decreaseFontSize, resetFontSize } = useTheme();
    const { createTerminal } = useTerminals();

    const [searchTerm, setSearchTerm] = useState('');
    const [selectedIndex, setSelectedIndex] = useState(0);
    const inputRef = useRef<HTMLInputElement>(null);
    const listRef = useRef<HTMLUListElement>(null);

    // --- Define All Available Commands (WITH ICONS) ---
    const allCommands = useMemo<Command[]>(() => {
        const commands: Command[] = [
            // --- App & Window Commands ---
            { id: 'app.quit', label: 'Application: Quit', icon: FaSignOutAlt, execute: () => window.electronAPI.app_quit() },
            { id: 'window.toggleDevTools', label: 'Developer: Toggle Developer Tools', icon: FaTools, execute: () => window.electronAPI.window_toggleDevTools() },
            { id: 'window.toggleFullscreen', label: 'View: Toggle Fullscreen', icon: FaExpandAlt, execute: () => window.electronAPI.window_toggleFullscreen() },

            // --- Terminal Commands ---
            { id: 'terminal.new', label: 'Terminal: New Terminal', icon: FaTerminal, execute: createTerminal },
            // { id: 'terminal.clear', label: 'Terminal: Clear Active Terminal', icon: FaBroom, execute: clearActiveTerminal }, // If added

            // --- File Commands ---
            {
                id: 'file.openFolder',
                label: 'File: Open Folder...',
                icon: FaFolderOpen,
                execute: async () => {
                    await window.electronAPI.dialog_openDirectory();
                }
            },
            // { id: 'file.save', label: 'File: Save Active File', icon: FaSave, execute: () => { /* ... */ } },

            // --- View/Theme Commands ---
            { id: 'view.increaseFontSize', label: 'View: Increase Font Size', icon: FaPlusSquare, execute: increaseFontSize },
            { id: 'view.decreaseFontSize', label: 'View: Decrease Font Size', icon: FaMinusSquare, execute: decreaseFontSize },
            { id: 'view.resetFontSize', label: 'View: Reset Font Size', icon: FaRedo, execute: resetFontSize }, // FaUndo or FaRedo could work

             ...availableThemes.map(th => ({
                id: `theme.set.${th.value}`,
                label: `Theme: Set ${th.label}`,
                icon: FaPalette, // Generic theme icon
                execute: () => setTheme(th.value),
            })),
        ];
        return commands.sort((a, b) => a.label.localeCompare(b.label));
    }, [setTheme, createTerminal, increaseFontSize, decreaseFontSize, resetFontSize]); // Add new context functions to dependency array

    // --- Filter Commands Based on Search Term ---
    const filteredCommands = useMemo(() => {
        if (!searchTerm.trim()) return allCommands;
        const lowerSearchTerm = searchTerm.toLowerCase();
        // Simple filter, could be enhanced with fuzzy search later
        return allCommands.filter(command =>
            command.label.toLowerCase().includes(lowerSearchTerm)
        );
    }, [searchTerm, allCommands]);

    // --- Effects (No change needed here) ---
    useEffect(() => {
        if (isOpen) {
            setSearchTerm('');
            setSelectedIndex(0);
            const timer = setTimeout(() => inputRef.current?.focus(), 50);
            return () => clearTimeout(timer);
        }
    }, [isOpen]);

    useEffect(() => {
        if (isOpen && listRef.current) {
            const selectedElement = listRef.current.querySelector('.selected') as HTMLLIElement;
            if (selectedElement) {
                selectedElement.scrollIntoView({ block: 'nearest' });
            }
        }
    }, [selectedIndex, isOpen, filteredCommands]);

    // --- Event Handlers (No change needed here) ---
    const handleKeyDown = useCallback((event: React.KeyboardEvent<HTMLInputElement>) => {
        if (event.key === 'Escape') {
            event.preventDefault();
            onClose();
        } else if (event.key === 'ArrowDown') {
            event.preventDefault();
            // Ensure selection wraps correctly within the bounds
             setSelectedIndex(prev => Math.min(prev + 1, filteredCommands.length - 1));
        } else if (event.key === 'ArrowUp') {
            event.preventDefault();
             setSelectedIndex(prev => Math.max(prev - 1, 0));
        } else if (event.key === 'Enter') {
            event.preventDefault();
            if (filteredCommands[selectedIndex]) {
                filteredCommands[selectedIndex].execute();
                onClose();
            }
        }
    }, [filteredCommands, selectedIndex, onClose]);

    const handleItemClick = useCallback((index: number) => {
        if (filteredCommands[index]) {
            filteredCommands[index].execute();
            onClose();
        }
    }, [filteredCommands, onClose]);

    // --- Render ---
    if (!isOpen) return null;

    return (
        <div className="command-palette-overlay" onMouseDown={onClose}>
            <div className="command-palette-container" onMouseDown={e => e.stopPropagation()}>
                <input
                    ref={inputRef}
                    type="text"
                    placeholder="Enter command..."
                    value={searchTerm}
                    onChange={e => { setSearchTerm(e.target.value); setSelectedIndex(0); }}
                    onKeyDown={handleKeyDown}
                    className="command-palette-input"
                    aria-label="Command Palette Input"
                    autoComplete="off"
                />
                <ul ref={listRef} className="command-palette-list" role="listbox">
                    {filteredCommands.length > 0 ? (
                        filteredCommands.map((command, index) => (
                            <li
                                key={command.id}
                                className={`command-palette-item ${index === selectedIndex ? 'selected' : ''}`}
                                onClick={() => handleItemClick(index)}
                                onMouseEnter={() => setSelectedIndex(index)}
                                role="option"
                                aria-selected={index === selectedIndex}
                                id={`command-palette-item-${index}`}
                            >
                                {/* Render Icon if it exists */}
                                {command.icon && <command.icon className="command-palette-icon" />}
                                <span className="command-palette-label">{command.label}</span>
                            </li>
                        ))
                    ) : (
                        <li className="command-palette-item no-results">No commands found</li>
                    )}
                </ul>
            </div>
        </div>
    );
};

export default CommandPalette;
// --- END FILE: src/renderer/components/CommandPalette.tsx ---
--- END FILE: src/renderer/components/CommandPalette.tsx ---

--- START FILE: src/renderer/components/Tab.tsx ---
// --- START FILE: src/renderer/components/Tab.tsx ---
import React, { useMemo } from 'react';
import path from 'path-browserify';
import { FaTimes } from 'react-icons/fa'; // Close icon

interface TabProps {
    filePath: string;
    isActive: boolean;
    isDirty: boolean;
    onClick: (filePath: string) => void;
    onClose: (filePath: string) => void;
    // No need for ref prop here, forwardRef handles it
}

// Use React.forwardRef to allow passing a ref to the underlying div
const Tab = React.forwardRef<HTMLDivElement, TabProps>(({
    filePath,
    isActive,
    isDirty,
    onClick,
    onClose
}, ref) => { // ref is the second argument provided by forwardRef
    const fileName = useMemo(() => path.basename(filePath), [filePath]);

    const handleCloseClick = (e: React.MouseEvent) => {
        e.stopPropagation(); // Prevent tab click when clicking close
        onClose(filePath);
    };

    const handleClick = () => {
        // Only call onClick if the tab is not already active
        if (!isActive) {
            onClick(filePath);
        }
    };

    return (
        // Assign the forwarded ref to this div
        <div
            ref={ref} // Assign the ref here
            className={`tab ${isActive ? 'active' : ''}`}
            onClick={handleClick}
            title={filePath}
            role="tab"
            aria-selected={isActive}
        >
            {isDirty && <span className="tab-dirty-indicator">●</span>}
            <span className="tab-filename">{fileName}</span>
            <button
                className="tab-close-button"
                onClick={handleCloseClick}
                title="Close Tab"
                aria-label={`Close ${fileName} tab`}
                type="button"
                // Make focusable only if the tab itself is active for better keyboard nav
                tabIndex={isActive ? 0 : -1}
            >
                <FaTimes />
            </button>
        </div>
    );
});

Tab.displayName = 'Tab'; // Good practice for dev tools when using forwardRef
export default Tab;
// --- END FILE: src/renderer/components/Tab.tsx ---
--- END FILE: src/renderer/components/Tab.tsx ---

--- START FILE: src/renderer/components/StatusBar.css ---
/* --- START FILE: src/renderer/components/StatusBar.css --- */
/* src/renderer/components/StatusBar.css */

.status-bar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-xxs) var(--spacing-sm);
    background-color: var(--color-bg-sidebar); /* Use sidebar bg or a dedicated one */
    color: var(--color-text-secondary);
    border-top: 1px solid var(--color-border);
    font-size: var(--font-size-sm);
    height: 24px; /* Fixed height */
    flex-shrink: 0; /* Prevent shrinking */
    overflow: hidden; /* Prevent content spill */
    user-select: none; /* Prevent text selection */
  }
  
  .status-bar-left,
  .status-bar-right {
    display: flex;
    align-items: center;
    /* --- Adjusted gap for potentially more items --- */
    gap: var(--spacing-md); /* Use medium gap between items */
    white-space: nowrap;
    overflow: hidden;
  }
  
  .status-bar-left {
      flex-grow: 1; /* Allow left side to take more space */
      min-width: 100px; /* Ensure some minimum space */
      margin-right: var(--spacing-md);
  }
  
  .status-bar-right {
      flex-shrink: 0; /* Prevent right side from shrinking too much */
      margin-left: auto; /* Push right items further right if space allows */
  }
  
  .status-item {
    display: inline-flex;
    align-items: center;
    cursor: default; /* Indicate non-interactive */
    /* Add some padding to separate visually */
    padding: 0 var(--spacing-xxs);
    border-radius: var(--border-radius-sm); /* Optional: slight rounding */
    transition: background-color 0.15s ease; /* Subtle hover */
  }
  
  /* Optional: Add hover effect to items if desired */
  /* .status-item:hover {
      background-color: var(--color-bg-hover);
      color: var(--color-text-primary);
  } */
  
  
  .status-item.file-path {
      overflow: hidden;
      text-overflow: ellipsis;
      padding-left: 0; /* No left padding for the first item */
  }
  
  .status-item .dirty-indicator {
      margin-left: var(--spacing-xxs);
      color: var(--color-text-accent); /* Use accent color */
      font-weight: bold;
  }
  
  .status-item.error-message {
      color: var(--color-text-error);
      margin-left: var(--spacing-xs); /* Add space before error icon */
      cursor: help; /* Indicate hover for tooltip */
  }
  
  .status-item.time {
      font-variant-numeric: tabular-nums; /* Keep time width consistent */
      min-width: 65px; /* Allocate space for HH:MM:SS */
      text-align: center;
  }
  
  /* Win95/mIRC Specifics */
  .theme-win95 .status-bar,
  .theme-mirc .status-bar {
      background-color: var(--color-bg-app);
      border-top: none;
      height: auto; /* Allow height adjustment based on font */
      min-height: 20px;
      padding: 1px var(--spacing-xs);
      /* Apply bevel using box-shadow (top inset) */
      box-shadow: inset 0px 1px var(--win95-bevel-shadow-light, transparent),
                  inset 0px 2px var(--win95-bevel-shadow-lighter, transparent);
  }
  .theme-win95 .status-item,
  .theme-mirc .status-item {
      /* Add slight inset shadow to mimic engraved text */
       text-shadow: 1px 1px var(--win95-bevel-shadow-dark);
       padding: 0 2px; /* Adjust padding */
       border-radius: 0;
  }
  
  /* Pip-Boy Specifics */
  .theme-pipboy .status-bar {
      background-color: var(--pipboy-bg-lighter);
      border-top-color: var(--pipboy-green-dark);
      color: var(--pipboy-green);
  }
  .theme-pipboy .status-item .dirty-indicator,
  .theme-pipboy .status-item.error-message {
      color: var(--pipboy-green); /* Keep green for indicators */
  }
  .theme-pipboy .status-item.error-message {
       font-weight: bold;
  }
  
  /* --- END FILE: src/renderer/components/StatusBar.css --- */
--- END FILE: src/renderer/components/StatusBar.css ---

--- START FILE: src/renderer/components/CustomSelect.tsx ---
// src/renderer/components/CustomSelect.tsx
import React, { useState, useRef, useEffect, ReactNode } from 'react';
import './CustomSelect.css'; // We'll create this CSS file next

interface CustomSelectOption<T extends string> {
  value: T;
  label: ReactNode; // Allow JSX for labels if needed
}

interface CustomSelectProps<T extends string> {
  options: CustomSelectOption<T>[];
  value: T;
  onChange: (value: T) => void;
  labelId?: string; // For accessibility
}

function CustomSelect<T extends string>({
  options,
  value,
  onChange,
  labelId,
}: CustomSelectProps<T>) {
  const [isOpen, setIsOpen] = useState(false);
  const selectRef = useRef<HTMLDivElement>(null);
  const selectedOption = options.find(option => option.value === value);

  // Close dropdown if clicked outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (selectRef.current && !selectRef.current.contains(event.target as Node)) {
        setIsOpen(false);
      }
    };
    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
    } else {
      document.removeEventListener('mousedown', handleClickOutside);
    }
    // Cleanup listener on unmount or when isOpen changes
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [isOpen]);

  const handleOptionClick = (optionValue: T) => {
    onChange(optionValue);
    setIsOpen(false);
  };

  const toggleOpen = () => {
    setIsOpen(!isOpen);
  };

  return (
    <div className="custom-select-container" ref={selectRef}>
      <button
        type="button"
        className="custom-select-trigger"
        onClick={toggleOpen}
        aria-haspopup="listbox"
        aria-expanded={isOpen}
        aria-labelledby={labelId} // Link to external label if provided
      >
        {selectedOption?.label || 'Select...'}
        <span className="custom-select-arrow">{isOpen ? '▲' : '▼'}</span>
      </button>
      {isOpen && (
        <ul
          className="custom-select-options"
          role="listbox"
          aria-activedescendant={value} // Indicate current selection
          aria-labelledby={labelId}
        >
          {options.map(option => (
            <li
              key={option.value}
              className={`custom-select-option ${option.value === value ? 'selected' : ''}`}
              onClick={() => handleOptionClick(option.value)}
              role="option"
              aria-selected={option.value === value}
              id={option.value} // Used for aria-activedescendant
            >
              {option.label}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}

export default CustomSelect;
--- END FILE: src/renderer/components/CustomSelect.tsx ---

--- START FILE: src/renderer/App.css ---
/* src/renderer/App.css */

.app-container {
    height: 100%;
    width: 100%;
    background-color: var(--color-bg-app);
    overflow: hidden;
    /* Use Flexbox to position main content and status bar */
    display: flex;
    flex-direction: column;
}

/* Wrapper for the main splitting area (Sidebar/MainPanel) */
.main-content-area {
    flex-grow: 1; /* Take up all available vertical space */
    overflow: hidden; /* Prevent its content from overflowing the container */
    position: relative; /* Needed for Allotment internals */
    display: flex; /* Ensure inner Allotment can fill this */
}

/* Ensure Allotment fills the main-content-area */
.main-content-area > .allotment-module--vertical-container___AllotmentVerticalContainer,
.main-content-area > .allotment-module--horizontal-container___AllotmentHorizontalContainer {
    flex-grow: 1;
}


.sidebar {
  background-color: var(--color-bg-sidebar);
  height: 100%;
  color: var(--color-text-primary);
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Sidebar Header */
.sidebar-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--spacing-sm) var(--spacing-md);
  border-bottom: var(--border-standard);
  flex-shrink: 0;
}

.sidebar-header h2 {
  margin: 0;
  font-size: var(--font-size-lg);
  color: var(--color-text-heading);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-grow: 1;
  margin-right: var(--spacing-sm);
}

.sidebar-header button.open-folder-button {
  flex-shrink: 0;
}

/* Navigation Controls */
.navigation-controls {
    display: flex;
    align-items: center;
    padding: var(--spacing-xs) var(--spacing-md);
    border-bottom: var(--border-standard);
    flex-shrink: 0;
    gap: var(--spacing-sm);
    min-height: 30px;
}

/* Base style for icon-only buttons */
.icon-button {
    background: none;
    border: none;
    padding: var(--spacing-xs);
    color: var(--color-text-secondary);
    cursor: pointer;
    border-radius: var(--border-radius-sm);
    display: inline-flex;
    align-items: center;
    justify-content: center;
    line-height: 1;
    font-size: var(--font-size-md);
}

.icon-button:hover {
    background-color: var(--color-bg-hover);
    color: var(--color-text-primary);
}
.icon-button:active {
    background-color: var(--color-bg-button-active);
}
.icon-button:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    background-color: transparent;
    color: var(--color-text-tertiary);
}

.navigation-controls .up-button {
    flex-shrink: 0;
}

/* Win95/mIRC Icon Button Overrides */
.theme-win95 .icon-button, .theme-mirc .icon-button {
   box-shadow: none; padding: var(--spacing-xs);
}
.theme-win95 .icon-button:active, .theme-mirc .icon-button:active {
   box-shadow: none;
}

.navigation-controls .current-folder-path {
    font-size: var(--font-size-sm);
    color: var(--color-text-tertiary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-grow: 1;
    padding: 0;
    border-bottom: none;
}

.sidebar svg {
    border: none;
    vertical-align: middle;
}

/* File Tree Styling */
.file-tree {
    flex-grow: 1;
    overflow-y: auto;
    min-height: 50px;
    padding: var(--spacing-xs) 0;
    font-size: var(--font-size-sm);
}
.file-tree ul { list-style: none; padding: 0; margin: 0; }
.file-tree-node.loading > .node-content { opacity: 0.7; cursor: default; }
.file-tree-node .node-content { display: flex; align-items: center; cursor: pointer; padding: var(--spacing-xxs) var(--spacing-md); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; user-select: none; position: relative; }
.file-tree-node .node-content:hover { background-color: var(--color-bg-hover); }
.file-tree-node .toggle-icon { width: 1.5em; display: inline-flex; align-items: center; justify-content: center; flex-shrink: 0; line-height: 1; vertical-align: middle; color: var(--color-text-tertiary); }
.file-tree-node .toggle-icon.spacer { visibility: hidden; }
.file-tree-node .expand-icon { font-size: 0.9em; display: inline-block; vertical-align: middle; }
.file-tree-node .file-icon { margin-right: var(--spacing-xs); display: inline-flex; align-items: center; flex-shrink: 0; vertical-align: middle; color: var(--color-text-accent); font-size: 1.1em; }
.file-tree-node .node-name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; vertical-align: middle; margin-left: var(--spacing-xxs); }
.file-tree-node .loading-spinner { display: inline-flex; align-items: center; justify-content: center; font-size: 0.9em; vertical-align: middle; color: var(--color-text-tertiary); }
.spin-animation { animation: spin 1.5s linear infinite; }
@keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
.file-tree-node .error-message, .file-tree-node .empty-folder-message { color: var(--color-text-tertiary); font-style: italic; padding: var(--spacing-xxs) 0; margin: 0; list-style: none; user-select: none; font-size: 0.9em; }
.file-tree-node .error-message { color: var(--color-text-error); font-style: normal; }
.file-tree .placeholder-message { color: var(--color-text-tertiary); padding: var(--spacing-md); font-style: italic; line-height: 1.5; }

/* Theme switcher styles */
.sidebar .theme-switcher { margin-top: auto; padding: var(--spacing-md); border-top: var(--border-standard); flex-shrink: 0; position: relative; z-index: 5; }
.sidebar .theme-switcher label { display: block; margin-bottom: var(--spacing-xs); font-size: var(--font-size-sm); color: var(--color-text-secondary); }

/* Main Panel, Editor, Terminal Base Styles */
.main-panel { display: flex; flex-direction: column; height: 100%; overflow: hidden; background-color: var(--color-bg-main); }
.editor-panel { background-color: var(--color-bg-editor); overflow: hidden; position: relative; height: 100%; width: 100%; display: flex; }

/* Wrapper for Terminal Tabs + Panel Area */
.terminal-area-container {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    overflow: hidden;
    background-color: var(--color-bg-terminal);
}

/* Wrapper for the absolutely positioned terminal panel instances */
.terminal-panels-wrapper {
  flex-grow: 1;
  overflow: hidden;
  position: relative;
  background-color: var(--color-bg-terminal);
}

/* Terminal Panel Instance Styling (Absolute Positioning) */
.terminal-panel-instance {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    /* Visibility Control */
    visibility: hidden; /* Hidden by default */
    opacity: 0;
    z-index: 1;
    transition: opacity 0.05s ease-out, visibility 0s linear 0.05s; /* Faster hide transition */
    /* Content Styling */
    display: flex; /* Needed for inner mount point to fill space */
    overflow: hidden;
    /* Padding applied to inner mount point now */
    background-color: var(--color-bg-terminal);
    color: var(--color-text-terminal);
    font-family: var(--font-family-mono);
    font-size: var(--font-size-terminal);
}

/* Style for the ACTIVE terminal panel */
.terminal-panel-instance.active {
    visibility: visible;
    opacity: 1;
    z-index: 2;
    transition: opacity 0.05s ease-in, visibility 0s linear; /* Faster show transition */
}

/* Container for Terminal Panel content + overlay button */
.terminal-panel-content-wrapper {
  position: relative; /* Enable absolute positioning for children */
  width: 100%;
  height: 100%;
  overflow: hidden; /* Ensure button doesn't cause overflow */
}

/* Style for the overlay clear button */
.terminal-clear-button-overlay {
  position: absolute;
  top: var(--spacing-xs);  /* Adjust spacing as needed */
  /* Push button further left to avoid scrollbar */
  right: calc(var(--spacing-sm) + 12px); /* Add space (~scrollbar width + gap) */
  z-index: 5; /* Ensure it's above the terminal content */
  padding: 2px 4px; /* Smaller padding */
  font-size: 0.8em; /* Smaller icon */
  background-color: color-mix(in srgb, var(--color-bg-terminal) 80%, black); /* Slightly darker semi-transparent background */
  color: var(--color-text-tertiary);
  border-radius: var(--border-radius-sm);
  opacity: 0.6; /* Make it less prominent */
  transition: opacity 0.15s ease, background-color 0.15s ease, color 0.15s ease;
}

.terminal-clear-button-overlay:hover {
  opacity: 1;
  background-color: color-mix(in srgb, var(--color-bg-button-hover) 85%, black);
  color: var(--color-text-primary);
}

.terminal-clear-button-overlay:active {
    background-color: color-mix(in srgb, var(--color-bg-button-active) 90%, black);
}

/* Adjust for specific themes if needed */
.theme-win95 .terminal-clear-button-overlay,
.theme-mirc .terminal-clear-button-overlay {
    background-color: var(--color-bg-button);
    color: var(--color-text-button);
    opacity: 0.8;
    border: 1px solid var(--win95-bevel-shadow-dark);
    box-shadow: inset -1px -1px 0 1px var(--win95-bevel-shadow-darker, transparent),
                inset 1px 1px 0 1px var(--win95-bevel-shadow-light, transparent);
    font-size: 0.9em;
    padding: 1px 3px;
    /* Ensure right positioning is consistent */
    right: calc(var(--spacing-sm) + 12px);
}
.theme-win95 .terminal-clear-button-overlay:hover,
.theme-mirc .terminal-clear-button-overlay:hover {
     opacity: 1;
}
.theme-win95 .terminal-clear-button-overlay:active,
.theme-mirc .terminal-clear-button-overlay:active {
    box-shadow: inset 1px 1px 0 1px var(--win95-bevel-shadow-darker, transparent),
                inset -1px -1px 0 1px var(--win95-bevel-shadow-light, transparent);
}

/* The actual mount point for xterm INSIDE the instance wrapper */
.terminal-mount-point {
    width: 100%;
    height: 100%;
    overflow: hidden;
    padding: var(--spacing-xs);
    padding-bottom: var(--spacing-sm)
}

/* Hide inactive xterm scrollbar track */
.terminal-mount-point .xterm-viewport::-webkit-scrollbar-track {
    background-color: transparent; /* Makes track invisible unless scrolling */
}

/* Placeholder for when no terminal is active/open */
.terminal-placeholder {
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--color-text-tertiary);
    padding: var(--spacing-md);
    font-style: italic;
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: var(--color-bg-terminal);
    z-index: 0;
}

/* Ensure xterm fills its container (.terminal-mount-point) */
.terminal-mount-point > div { width: 100%; height: 100%; }
.terminal-mount-point .terminal.xterm { height: 100% !important; width: 100% !important; }
.terminal-mount-point .xterm-screen { width: 100% !important; height: 100% !important; }
.terminal-mount-point .xterm-viewport { width: 100% !important; }
.terminal-mount-point .xterm .xterm-screen canvas { width: 100% !important; height: 100% !important; }
.terminal-mount-point p { display: none; }

/* Editor Panel Overlay Indicators */
.editor-context-error, .editor-loading-indicator {
    position: absolute; top: var(--spacing-xs); left: var(--spacing-sm);
    background-color: color-mix(in srgb, var(--color-bg-editor) 90%, black);
    padding: var(--spacing-xxs) var(--spacing-xs); border-radius: var(--border-radius-sm);
    font-size: var(--font-size-sm); z-index: 10; box-shadow: var(--box-shadow-sm); max-width: 80%;
}
.editor-context-error { color: var(--color-text-error); border: 1px solid var(--color-text-error); }
.editor-loading-indicator { color: var(--color-text-secondary); border: 1px solid var(--color-border-accent); }

/* StatusBar is handled by its own CSS file (StatusBar.css) */
/* No specific styles needed here unless overriding something */
--- END FILE: src/renderer/App.css ---

--- START FILE: src/main/env.d.ts ---
interface ImportMetaEnv {
    // Add environment variables used by your main process code here
    readonly VITE_DEV_SERVER_URL?: string; // Optional: Used by Electron window loading logic
    readonly PROD: boolean; // Based on your usage 'import.meta.env.PROD'
    readonly DEV: boolean; // Often useful to have DEV as well
    // Add any other custom VITE_ prefixed variables you might use in main.ts
    // readonly VITE_MY_API_KEY: string;
  }
  
  interface ImportMeta {
    readonly env: ImportMetaEnv;
  }
--- END FILE: src/main/env.d.ts ---

--- START FILE: src/main/index.ts ---
// --- START FILE: src/main/index.ts ---
// src/main/index.ts
import { app, BrowserWindow, shell, ipcMain, dialog, Menu, MenuItemConstructorOptions } from 'electron';
import path from 'node:path';
import os from 'node:os';
import * as pty from 'node-pty';
import fs from 'node:fs/promises'; // Import fs promises

// Import shared types (ensure paths are correct in your tsconfig for build)
import type {
    DirectoryEntry, ReadDirectoryResponse, ReadFileResponse, SaveFileResponse,
    PtyCreateOptions, PtyResizeOptions, PtyCreateResponse // Import terminal types
} from '../shared.types';

// --- Global Variables ---
app.disableHardwareAcceleration();
const shellPath = os.platform() === 'win32' ? 'powershell.exe' : 'bash';
// --- Terminal Management ---
// Use a Map to store multiple PTY processes, keyed by their unique ID
const ptyInstances = new Map<string, pty.IPty>();
let mainWindow: BrowserWindow | null = null;


// --- Squirrel Startup Handler (Windows Installer) ---
if (app.isPackaged && process.platform === 'win32') {
    if (require('electron-squirrel-startup')) {
      app.quit();
    }
}

// Function to create the application menu
function createApplicationMenu() {
    const isMac = process.platform === 'darwin';

    const template: MenuItemConstructorOptions[] = [
        // { role: 'appMenu' } // Mac-specific File menu items
        ...(isMac ? [{
            label: app.name,
            submenu: [
                { role: 'about' },
                { type: 'separator' },
                { role: 'services' },
                { type: 'separator' },
                { role: 'hide' },
                { role: 'hideOthers' },
                { role: 'unhide' },
                { type: 'separator' },
                { role: 'quit' } // Cmd+Q
            ]
        }] : []) as MenuItemConstructorOptions[],
        // { role: 'fileMenu' } // Standard File menu
        {
            label: 'File',
            submenu: [
                isMac ? { role: 'close' } : { role: 'quit' } // Alt+F4 (Win/Linux), Cmd+W (Mac) vs Cmd+Q
            ]
        },
        // { role: 'editMenu' }
        {
            label: 'Edit',
            submenu: [
                { role: 'undo' },
                { role: 'redo' },
                { type: 'separator' },
                { role: 'cut' },
                { role: 'copy' },
                { role: 'paste' },
                ...(isMac ? [
                    { role: 'pasteAndMatchStyle' },
                    { role: 'delete' },
                    { role: 'selectAll' },
                    { type: 'separator' },
                    {
                        label: 'Speech',
                        submenu: [
                            { role: 'startSpeaking' },
                            { role: 'stopSpeaking' }
                        ]
                    }
                ] : [
                    { role: 'delete' },
                    { type: 'separator' },
                    { role: 'selectAll' }
                ]) as MenuItemConstructorOptions[]
            ]
        },
        // { role: 'viewMenu' }
        {
            label: 'View',
            submenu: [
                { role: 'reload' }, // Ctrl+R / Cmd+R
                { role: 'forceReload' }, // Ctrl+Shift+R / Cmd+Shift+R
                { role: 'toggleDevTools' }, // F12 / Ctrl+Shift+I / Cmd+Option+I
                { type: 'separator' },
                { role: 'resetZoom' },
                { role: 'zoomIn' },
                { role: 'zoomOut' },
                { type: 'separator' },
                { role: 'togglefullscreen' } // F11 / Ctrl+Cmd+F
            ]
        },
        // { role: 'windowMenu' } // Standard Window menu (Minimize, Zoom, etc.)
         {
             label: 'Window',
             submenu: [
                 { role: 'minimize' },
                 { role: 'zoom' },
                 ...(isMac ? [
                     { type: 'separator' },
                     { role: 'front' },
                     { type: 'separator' },
                     { role: 'window' }
                 ] : [
                     { role: 'close' } // Closes the window, not quit app
                 ]) as MenuItemConstructorOptions[]
             ]
         },
         // { role: 'help' } // Optional Help menu
         {
            role: 'help',
            submenu: [
                {
                    label: 'Learn More (Electron)',
                    click: async () => {
                        await shell.openExternal('https://electronjs.org')
                    }
                }
            ]
         }
    ];

    const menu = Menu.buildFromTemplate(template);
    Menu.setApplicationMenu(menu);
    console.log("Application menu created and set.");
}


// --- Main Window Creation Function ---
function createWindow() {
  console.log('Creating main window...');
  mainWindow = new BrowserWindow({
    width: 1200, // Initial width (will be overridden by fullscreen)
    height: 800, // Initial height (will be overridden by fullscreen)
    fullscreen: true,
    webPreferences: {
      preload: path.join(__dirname, '../preload/index.js'),
      nodeIntegration: false,
      contextIsolation: true,
    },
  });

  const isDev = !app.isPackaged;
  const VITE_DEV_SERVER_URL = 'http://localhost:5173';

  console.log(`>>> DEBUG: app.isPackaged = ${app.isPackaged}, therefore isDev = ${isDev}`);

  if (isDev && VITE_DEV_SERVER_URL) {
    console.log(`Loading DEV URL: ${VITE_DEV_SERVER_URL}`);
    mainWindow.loadURL(VITE_DEV_SERVER_URL)
      .catch(err => console.error('Failed to load DEV URL:', err));
  } else {
    console.log('Loading PROD build file');
    const prodPath = path.join(__dirname, '..', 'renderer', 'index.html');
    console.log(`Attempting to load production file: ${prodPath}`);
    mainWindow.loadFile(prodPath)
       .catch(err => console.error(`Failed to load PROD file: ${prodPath}`, err));
  }

  // --- Window Event Handlers ---
  mainWindow.webContents.setWindowOpenHandler(({ url }) => {
    if (url.startsWith('http:') || url.startsWith('https:')) {
        shell.openExternal(url);
    }
    return { action: 'deny' };
  });

  mainWindow.webContents.on('render-process-gone', (_event, details) => {
    console.error('Renderer process gone:', details);
  });

  mainWindow.webContents.on('did-fail-load', (_event, errorCode, errorDescription, validatedURL) => {
    console.error(`Failed to load URL: ${validatedURL}, ErrorCode: ${errorCode}, Description: ${errorDescription}`);
   });

  mainWindow.on('closed', () => {
    console.log('Main window closed.');
    console.log(`Main window closed. Killing ${ptyInstances.size} PTY process(es).`);
    ptyInstances.forEach((pty, id) => {
        console.log(`Killing PTY process ID: ${id} (PID: ${pty.pid})`);
        try { pty.kill(); } catch (e) { console.warn(`Error killing PTY ID ${id}:`, e); }
    });
    ptyInstances.clear();
    mainWindow = null;
  });

}

// --- Function to Kill a Specific PTY Process ---
function killPtyProcess(id: string) {
    const ptyProcess = ptyInstances.get(id);
    if (ptyProcess) {
        console.log(`Killing PTY process ID: ${id} (PID: ${ptyProcess.pid})`);
        try {
            ptyProcess.kill();
        } catch (e) {
             console.warn(`Error killing PTY ID ${id}:`, e);
        } finally {
             ptyInstances.delete(id);
             console.log(`PTY process ID: ${id} removed from map.`);
        }
    } else {
        console.warn(`Attempted to kill PTY process ID: ${id}, but it was not found in the map.`);
    }
}


// --- Function to Setup IPC Handlers ---
function setupIpcHandlers() {
    console.log('Setting up IPC Handlers...');

    // Basic Ping Example
    ipcMain.handle('ping', () => 'pong from main!');

    // --- PTY Handlers ---
    ipcMain.handle('pty-create', async (_event, options: PtyCreateOptions): Promise<PtyCreateResponse> => {
        if (!mainWindow) {
            console.error("Cannot create PTY: mainWindow is not available.");
            return { success: false, error: "Main window not available." };
        }
        const targetWebContents = mainWindow.webContents;
        const { id, cols, rows } = options;

        if (!id) {
            console.error("Cannot create PTY: Missing required 'id'.");
            return { success: false, error: "Missing terminal ID." };
        }

        if (ptyInstances.has(id)) {
            console.warn(`PTY process with ID ${id} already exists. Killing old one.`);
            killPtyProcess(id);
        }

        console.log(`Creating PTY process for ID: ${id}, shell: ${shellPath}, cols: ${cols}, rows: ${rows}`);
        try {
            const cwd = process.env.HOME || process.env.USERPROFILE || process.cwd();
            console.log(`PTY (ID: ${id}) current working directory: ${cwd}`);
            const newPtyProcess = pty.spawn(shellPath, [], {
                name: 'xterm-color',
                cols: cols || 80,
                rows: rows || 24,
                cwd: cwd,
                env: { ...process.env },
            });

            console.log(`PTY process created successfully for ID: ${id} (PID: ${newPtyProcess.pid}). Storing in map.`);
            ptyInstances.set(id, newPtyProcess);

            newPtyProcess.onData(data => {
                 if (targetWebContents && !targetWebContents.isDestroyed()) {
                    targetWebContents.send('pty-data', id, data);
                 }
            });

            newPtyProcess.onExit(({ exitCode, signal }) => {
                console.log(`PTY process ID: ${id} (PID: ${newPtyProcess.pid}) exited with code: ${exitCode}, signal: ${signal}`);
                 if (targetWebContents && !targetWebContents.isDestroyed()) {
                    targetWebContents.send('pty-exit', id, exitCode);
                    if (exitCode !== 0 || signal) {
                         targetWebContents.send('pty-error', id, `Process exited abnormally (Code: ${exitCode}, Signal: ${signal})`);
                    }
                 }
                 ptyInstances.delete(id);
                 console.log(`PTY process ID: ${id} removed from map due to exit.`);
            });

            return { success: true };

        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            console.error(`Failed to create PTY process for ID ${id}:`, error);
            if (targetWebContents && !targetWebContents.isDestroyed()) {
                targetWebContents.send('pty-error', id, `Failed to spawn PTY: ${errorMsg}`);
            }
            if (ptyInstances.has(id)) {
                ptyInstances.delete(id);
            }
            return { success: false, error: errorMsg };
        }
    });

    ipcMain.on('pty-input', (_event, id: string, data: string) => {
        const ptyProcess = ptyInstances.get(id);
        if (ptyProcess) {
             try {
                 ptyProcess.write(data);
             } catch (error) {
                 const errorMsg = error instanceof Error ? error.message : String(error);
                 console.error(`Error writing to PTY ID ${id} (PID: ${ptyProcess.pid}):`, error);
                 mainWindow?.webContents.send('pty-error', id, `Write Error: ${errorMsg}`);
             }
        }
    });

    ipcMain.on('pty-resize', (_event, id: string, options: PtyResizeOptions) => {
        const ptyProcess = ptyInstances.get(id);
        if (ptyProcess) {
            if (options.cols > 0 && options.rows > 0) {
                try {
                    ptyProcess.resize(options.cols, options.rows);
                } catch (error) {
                     const errorMsg = error instanceof Error ? error.message : String(error);
                     console.error(`Failed to resize PTY ID ${id} (PID: ${ptyProcess.pid}):`, error);
                     mainWindow?.webContents.send('pty-error', id, `Resize Error: ${errorMsg}`);
                }
            } else {
                console.warn(`Received invalid resize dimensions for PTY ID ${id}: cols=${options.cols}, rows=${options.rows}`);
            }
        }
    });

    ipcMain.handle('pty-kill', async (_event, id: string) => {
         console.log(`IPC Request: Kill PTY ID: ${id}`);
         if (!id) {
            console.error("Cannot kill PTY: Missing required 'id'.");
            return { success: false, error: "Missing terminal ID." };
         }
         try {
             killPtyProcess(id);
             return { success: true };
         } catch(error) {
             const errorMsg = error instanceof Error ? error.message : String(error);
             console.error(`Error processing kill request for PTY ID ${id}:`, error);
             return { success: false, error: errorMsg };
         }
     });


    // --- Dialog Handler ---
    ipcMain.handle('dialog:openDirectory', async () => {
        if (!mainWindow) return null;
        const { canceled, filePaths } = await dialog.showOpenDialog(mainWindow, {
            properties: ['openDirectory']
        });
        if (canceled || filePaths.length === 0) {
            return null;
        } else {
            console.log(`Directory selected: ${filePaths[0]}`);
            return filePaths[0];
        }
    });

    // --- File System Handlers ---

    // Read Directory Handler
    ipcMain.handle('fs:readDirectory', async (_event, folderPath: string): Promise<ReadDirectoryResponse> => {
        console.log(`IPC Request: Reading directory - ${folderPath}`);
        try {
            if (!folderPath || typeof folderPath !== 'string') {
                 throw new Error("Invalid folder path provided.");
            }
            const stats = await fs.stat(folderPath);
            if (!stats.isDirectory()) {
                throw new Error(`Path is not a directory: ${folderPath}`);
            }

            const dirents = await fs.readdir(folderPath, { withFileTypes: true });
            const entries: DirectoryEntry[] = dirents.map(dirent => ({
                name: dirent.name,
                path: path.join(folderPath, dirent.name),
                isDirectory: dirent.isDirectory(),
            }));
            entries.sort((a, b) => {
                if (a.isDirectory && !b.isDirectory) return -1;
                if (!a.isDirectory && b.isDirectory) return 1;
                return a.name.localeCompare(b.name);
            });

            console.log(`IPC Success: Read ${entries.length} entries from ${folderPath}`);
            return { success: true, entries: entries };
        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            console.error(`IPC Error: Failed to read directory ${folderPath}:`, errorMsg);
            if (error instanceof Error && 'code' in error) {
                if (error.code === 'EACCES') return { success: false, error: `Permission denied: ${folderPath}` };
                if (error.code === 'ENOENT') return { success: false, error: `Directory not found: ${folderPath}` };
            }
            return { success: false, error: errorMsg };
        }
    });

    // Read File Handler
    ipcMain.handle('fs:readFile', async (_event, filePath: string): Promise<ReadFileResponse> => {
        console.log(`IPC Request: Reading file - ${filePath}`);
        try {
            if (!filePath || typeof filePath !== 'string') {
                 throw new Error("Invalid file path provided.");
            }
            const stats = await fs.stat(filePath);
            if (!stats.isFile()) {
                throw new Error(`Path is not a file: ${filePath}`);
            }
            const content = await fs.readFile(filePath, { encoding: 'utf-8' });
            console.log(`IPC Success: Read file ${filePath}`);
            return { success: true, content: content };
        } catch (error) {
             const errorMsg = error instanceof Error ? error.message : String(error);
            console.error(`IPC Error: Failed to read file ${filePath}:`, errorMsg);
             if (error instanceof Error && 'code' in error) {
                if (error.code === 'EACCES') return { success: false, error: `Permission denied: ${filePath}` };
                if (error.code === 'ENOENT') return { success: false, error: `File not found: ${filePath}` };
             }
            return { success: false, error: errorMsg };
        }
    });

    // Save File Handler
    ipcMain.handle('fs:saveFile', async (_event, filePath: string, content: string): Promise<SaveFileResponse> => {
         // *** ADDED LOGS ***
         console.log(`[Main IPC -> fs:saveFile] Received save request for: ${filePath}`);
         console.log(`[Main IPC -> fs:saveFile] Received content length: ${content?.length ?? 'undefined'}`);
         console.log(`[Main IPC -> fs:saveFile] Received content start:`, content?.substring(0, 50) + '...');

         try {
             if (!filePath || typeof filePath !== 'string') {
                  throw new Error("Invalid file path provided.");
             }
              if (content === undefined || content === null) {
                   throw new Error("Invalid content provided for saving.");
             }
             await fs.writeFile(filePath, content, { encoding: 'utf-8' });
             // *** MODIFIED LOG ***
             console.log(`[Main IPC -> fs:saveFile] fs.writeFile SUCCEEDED for ${filePath}. Returning { success: true }`);
             return { success: true };
         } catch (error) {
             const errorMsg = error instanceof Error ? error.message : String(error);
             // *** MODIFIED LOG ***
             console.error(`[Main IPC -> fs:saveFile] fs.writeFile FAILED for ${filePath}:`, errorMsg);
             if (error instanceof Error && 'code' in error) {
                if (error.code === 'EACCES') return { success: false, error: `Permission denied: ${filePath}` };
                if (error.code === 'ENOENT') return { success: false, error: `Directory not found for file: ${filePath}` }; // Or similar
             }
              // *** ADDED LOG ***
             console.log(`[Main IPC -> fs:saveFile] Returning { success: false, error: ${errorMsg} }`);
             return { success: false, error: errorMsg };
         }
     });

    // --- App/Window Control Handlers ---
    ipcMain.handle('app:quit', () => {
        console.log("IPC: Received app:quit request.");
        app.quit();
    });

    ipcMain.handle('window:toggle-fullscreen', () => {
        if (mainWindow) {
            const isFullScreen = mainWindow.isFullScreen();
            console.log(`IPC: Toggling fullscreen (currently ${isFullScreen}).`);
            mainWindow.setFullScreen(!isFullScreen);
        } else {
            console.warn("IPC: Cannot toggle fullscreen, mainWindow not found.");
        }
    });

    ipcMain.handle('window:toggle-devtools', () => {
        if (mainWindow) {
            console.log("IPC: Toggling DevTools.");
            mainWindow.webContents.toggleDevTools();
        } else {
            console.warn("IPC: Cannot toggle DevTools, mainWindow not found.");
        }
    });


    console.log('IPC Handlers registered (including multi-PTY support and app/window controls).');
}

// --- App Lifecycle Events ---
app.whenReady().then(() => {
  console.log('App is ready.');
  setupIpcHandlers();
  createApplicationMenu();
  createWindow();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) {
        console.log('App activated, creating window.');
        createWindow();
    }
  });
});

app.on('window-all-closed', () => {
  console.log('All windows closed.');
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('will-quit', () => {
    console.log(`App will quit. Killing ${ptyInstances.size} PTY process(es).`);
    ptyInstances.forEach((pty, id) => {
        console.log(`Killing PTY process ID: ${id} (PID: ${pty.pid})`);
         try { pty.kill(); } catch (e) { console.warn(`Error killing PTY ID ${id}:`, e); }
    });
    ptyInstances.clear();
});

process.on('uncaughtException', (error: Error) => {
    console.error('Uncaught Main Process Exception:', error);
    if (error.message.includes('EPIPE')) {
        console.warn("Ignoring EPIPE error in main process.");
        return;
    }
    dialog.showErrorBox('Unhandled Main Process Error', `${error.name}: ${error.message}\n${error.stack ?? ''}`);
});
// --- END FILE: src/main/index.ts ---
--- END FILE: src/main/index.ts ---

--- START FILE: src/shared.types.ts ---
// --- START FILE: src/shared.types.ts ---
// src/shared.types.ts

// This file can be used to define types that are shared
// between the main process, preload script, and renderer process.

// --- Filesystem Types ---
export interface DirectoryEntry {
    name: string;       // File or folder name (e.g., 'index.ts', 'components')
    path: string;       // Full absolute path
    isDirectory: boolean; // True if it's a directory, false if it's a file
    // Add more properties later if needed (e.g., size, modified date)
}

// Define the expected response structure for reading a directory
export type ReadDirectoryResponse = {
    success: true;
    entries: DirectoryEntry[];
} | {
    success: false;
    error: string;
};

// Define the expected response structure for reading a file
export type ReadFileResponse = {
    success: true;
    content: string;
} | {
    success: false;
    error: string;
};

// Define the expected response structure for saving a file
export type SaveFileResponse = {
    success: boolean;
    error?: string;
};

// --- Terminal Types ---
export interface PtyCreateOptions {
    id: string; // Unique identifier for the terminal session
    cols: number;
    rows: number;
}

export interface PtyResizeOptions {
    cols: number;
    rows: number;
}

export type PtyCreateResponse = {
    success: boolean;
    error?: string;
};

// Example:
// export interface UserPreferences {
//   theme: string;
//   fontSize: number;
// }
// --- END FILE: src/shared.types.ts ---
--- END FILE: src/shared.types.ts ---

--- START FILE: src/preload/index.ts ---
// --- START FILE: src/preload/index.ts ---
// src/preload/index.ts
import { contextBridge, ipcRenderer, IpcRendererEvent } from 'electron';
// Import the shared types
import type {
    ReadDirectoryResponse, ReadFileResponse, SaveFileResponse,
    PtyCreateOptions, PtyResizeOptions, PtyCreateResponse // Import terminal types
} from '../shared.types';


// --- Define the shape of the API exposed to the Renderer ---
export interface ElectronAPI {
  // Basic example
  ping: () => Promise<string>;

  // Terminal specific API (MODIFIED FOR MULTIPLE TERMINALS)
  term_create: (options: PtyCreateOptions) => Promise<PtyCreateResponse>;
  term_write: (id: string, data: string) => void; // Requires ID
  term_resize: (id: string, options: PtyResizeOptions) => void; // Requires ID
  term_kill: (id: string) => Promise<{ success: boolean; error?: string }>; // New: Kill specific PTY
  // Listeners now include the ID in the callback
  term_onData: (callback: (id: string, data: string) => void) => () => void;
  term_onExit: (callback: (id: string, code?: number) => void) => () => void;
  term_onError: (callback: (id: string, errorMessage: string) => void) => () => void;

  // Dialog (Filesystem access via Main)
  dialog_openDirectory: () => Promise<string | null>; // Returns selected path or null

  // File System API
  fs_readDirectory: (folderPath: string) => Promise<ReadDirectoryResponse>; // Reads directory contents
  fs_readFile: (filePath: string) => Promise<ReadFileResponse>; // Reads file content
  fs_saveFile: (filePath: string, content: string) => Promise<SaveFileResponse>; // Saves file content

  // App/Window Control API
  app_quit: () => Promise<void>;
  window_toggleFullscreen: () => Promise<void>;
  window_toggleDevTools: () => Promise<void>;
}

// --- Implementation of the API ---
const api: ElectronAPI = {
  ping: () => ipcRenderer.invoke('ping'),

  // Terminal methods (MODIFIED)
  term_create: (options) => ipcRenderer.invoke('pty-create', options),
  term_write: (id, data) => ipcRenderer.send('pty-input', id, data), // Send ID
  term_resize: (id, options) => ipcRenderer.send('pty-resize', id, options), // Send ID
  term_kill: (id) => ipcRenderer.invoke('pty-kill', id), // New invoke

  // Terminal listeners (MODIFIED - expect ID as first arg from main)
  term_onData: (callback) => {
    const subscription = (_event: IpcRendererEvent, id: string, data: string) => callback(id, data);
    ipcRenderer.on('pty-data', subscription);
    // Return a function to unsubscribe
    return () => {
      ipcRenderer.removeListener('pty-data', subscription);
      console.log("Preload: Unsubscribed from pty-data"); // DEBUG
    };
  },
  term_onExit: (callback) => {
     const subscription = (_event: IpcRendererEvent, id: string, code?: number) => callback(id, code);
     ipcRenderer.on('pty-exit', subscription);
     // Return a function to unsubscribe
     return () => {
       ipcRenderer.removeListener('pty-exit', subscription);
       console.log("Preload: Unsubscribed from pty-exit"); // DEBUG
     };
  },
  term_onError: (callback) => {
    const subscription = (_event: IpcRendererEvent, id: string, errorMessage: string) => callback(id, errorMessage);
    ipcRenderer.on('pty-error', subscription);
    // Return a function to unsubscribe
    return () => {
      ipcRenderer.removeListener('pty-error', subscription);
       console.log("Preload: Unsubscribed from pty-error"); // DEBUG
    };
 },

  // Dialog methods (Unchanged)
  dialog_openDirectory: () => ipcRenderer.invoke('dialog:openDirectory'),

  // File System Methods (Unchanged)
  fs_readDirectory: (folderPath) => ipcRenderer.invoke('fs:readDirectory', folderPath),
  fs_readFile: (filePath) => ipcRenderer.invoke('fs:readFile', filePath),
  fs_saveFile: (filePath, content) => ipcRenderer.invoke('fs:saveFile', filePath, content),

  // App/Window Control Methods (Unchanged)
  app_quit: () => ipcRenderer.invoke('app:quit'),
  window_toggleFullscreen: () => ipcRenderer.invoke('window:toggle-fullscreen'),
  window_toggleDevTools: () => ipcRenderer.invoke('window:toggle-devtools'),
};

// --- Expose the API to the Renderer process ---
try {
  contextBridge.exposeInMainWorld('electronAPI', api);
  console.log('Preload script exposed electronAPI successfully (including multi-terminal and app/window controls).');
} catch (error) {
  console.error('Error exposing context bridge in preload script:', error);
}
// --- END FILE: src/preload/index.ts ---
--- END FILE: src/preload/index.ts ---

--- START FILE: codebase.txt ---
--- END FILE: codebase.txt ---

--- START FILE: package.json ---
{
  "name": "codecraft-ide",
  "version": "0.1.0",
  "description": "A custom IDE built with Electron, React, and TypeScript",
  "main": "dist-electron/main/index.js",
  "scripts": {
    "start": "electron .",
    "dev:vite": "vite --config vite.config.mjs --debug",
    "dev:main": "tsc --project tsconfig.node.json --watch",
    "dev": "echo \"Run 'npm run dev:main' and 'npm run dev:vite' in separate terminals, then 'npm start'\" && exit 1",
    "build:main": "tsc --project tsconfig.node.json",
    "build:renderer": "vite build --config vite.config.mjs",
    "build": "npm run clean && npm run build:main && npm run build:renderer && electron-builder",
    "rebuild": "electron-rebuild -f -w node-pty",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "clean": "rm -rf dist dist-electron build release",
    "postinstall": "electron-builder install-app-deps && npm run rebuild"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "allotment": "^1.20.3",
    "electron-squirrel-startup": "^1.0.1",
    "node-pty": "^1.0.0",
    "path-browserify": "^1.0.1",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-icons": "^5.5.0",
    "react-monaco-editor": "^0.58.0",
    "uuid": "^9.0.1", 
    "xterm": "^5.3.0",
    "xterm-addon-fit": "^0.8.0"
  },
  "devDependencies": {
    "@types/node": "^20.14.2",
    "@types/path-browserify": "^1.0.3",
    "@types/react": "^18.3.3",
    "@types/react-dom": "^18.3.0",
    "@types/uuid": "^9.0.8", 
    "@typescript-eslint/eslint-plugin": "^7.12.0",
    "@typescript-eslint/parser": "^7.12.0",
    "@vitejs/plugin-react": "^4.3.1",
    "electron": "^30.0.9",
    "electron-builder": "^24.13.3",
    "electron-rebuild": "^3.2.9",
    "eslint": "^8.57.0",
    "eslint-plugin-react": "^7.34.2",
    "eslint-plugin-react-hooks": "^4.6.2",
    "typescript": "^5.4.5",
    "vite": "^5.2.12",
    "vite-plugin-monaco-editor": "^1.1.0",
    "vite-plugin-node-polyfills": "^0.23.0"
  },
  "build": {
    "appId": "com.example.codecraftide",
    "productName": "CodeCraft IDE",
    "files": [
      "dist/**/*",
      "dist-electron/**/*",
      "index.html",
      "package.json"
    ],
    "directories": {
      "buildResources": "assets",
      "output": "release/${version}"
    },
    "win": {
      "target": "nsis",
      "icon": "assets/icon.ico"
    },
    "mac": {
      "target": "dmg",
      "icon": "assets/icon.icns"
    },
    "linux": {
      "target": "AppImage",
      "icon": "assets/icon.png"
    },
    "nsis": {
      "oneClick": false,
      "allowToChangeInstallationDirectory": true
    }
  }
}
--- END FILE: package.json ---

--- START FILE: dist-electron/shared.types.d.ts ---
export interface DirectoryEntry {
    name: string;
    path: string;
    isDirectory: boolean;
}
export type ReadDirectoryResponse = {
    success: true;
    entries: DirectoryEntry[];
} | {
    success: false;
    error: string;
};
export type ReadFileResponse = {
    success: true;
    content: string;
} | {
    success: false;
    error: string;
};
export type SaveFileResponse = {
    success: boolean;
    error?: string;
};
export interface PtyCreateOptions {
    id: string;
    cols: number;
    rows: number;
}
export interface PtyResizeOptions {
    cols: number;
    rows: number;
}
export type PtyCreateResponse = {
    success: boolean;
    error?: string;
};
--- END FILE: dist-electron/shared.types.d.ts ---

--- START FILE: dist-electron/main/index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// --- START FILE: src/main/index.ts ---
// src/main/index.ts
const electron_1 = require("electron");
const node_path_1 = __importDefault(require("node:path"));
const node_os_1 = __importDefault(require("node:os"));
const pty = __importStar(require("node-pty"));
const promises_1 = __importDefault(require("node:fs/promises")); // Import fs promises
// --- Global Variables ---
electron_1.app.disableHardwareAcceleration();
const shellPath = node_os_1.default.platform() === 'win32' ? 'powershell.exe' : 'bash';
// --- Terminal Management ---
// Use a Map to store multiple PTY processes, keyed by their unique ID
const ptyInstances = new Map();
let mainWindow = null;
// --- Squirrel Startup Handler (Windows Installer) ---
if (electron_1.app.isPackaged && process.platform === 'win32') {
    if (require('electron-squirrel-startup')) {
        electron_1.app.quit();
    }
}
// Function to create the application menu
function createApplicationMenu() {
    const isMac = process.platform === 'darwin';
    const template = [
        // { role: 'appMenu' } // Mac-specific File menu items
        ...(isMac ? [{
                label: electron_1.app.name,
                submenu: [
                    { role: 'about' },
                    { type: 'separator' },
                    { role: 'services' },
                    { type: 'separator' },
                    { role: 'hide' },
                    { role: 'hideOthers' },
                    { role: 'unhide' },
                    { type: 'separator' },
                    { role: 'quit' } // Cmd+Q
                ]
            }] : []),
        // { role: 'fileMenu' } // Standard File menu
        {
            label: 'File',
            submenu: [
                isMac ? { role: 'close' } : { role: 'quit' } // Alt+F4 (Win/Linux), Cmd+W (Mac) vs Cmd+Q
            ]
        },
        // { role: 'editMenu' }
        {
            label: 'Edit',
            submenu: [
                { role: 'undo' },
                { role: 'redo' },
                { type: 'separator' },
                { role: 'cut' },
                { role: 'copy' },
                { role: 'paste' },
                ...(isMac ? [
                    { role: 'pasteAndMatchStyle' },
                    { role: 'delete' },
                    { role: 'selectAll' },
                    { type: 'separator' },
                    {
                        label: 'Speech',
                        submenu: [
                            { role: 'startSpeaking' },
                            { role: 'stopSpeaking' }
                        ]
                    }
                ] : [
                    { role: 'delete' },
                    { type: 'separator' },
                    { role: 'selectAll' }
                ])
            ]
        },
        // { role: 'viewMenu' }
        {
            label: 'View',
            submenu: [
                { role: 'reload' }, // Ctrl+R / Cmd+R
                { role: 'forceReload' }, // Ctrl+Shift+R / Cmd+Shift+R
                { role: 'toggleDevTools' }, // F12 / Ctrl+Shift+I / Cmd+Option+I
                { type: 'separator' },
                { role: 'resetZoom' },
                { role: 'zoomIn' },
                { role: 'zoomOut' },
                { type: 'separator' },
                { role: 'togglefullscreen' } // F11 / Ctrl+Cmd+F
            ]
        },
        // { role: 'windowMenu' } // Standard Window menu (Minimize, Zoom, etc.)
        {
            label: 'Window',
            submenu: [
                { role: 'minimize' },
                { role: 'zoom' },
                ...(isMac ? [
                    { type: 'separator' },
                    { role: 'front' },
                    { type: 'separator' },
                    { role: 'window' }
                ] : [
                    { role: 'close' } // Closes the window, not quit app
                ])
            ]
        },
        // { role: 'help' } // Optional Help menu
        {
            role: 'help',
            submenu: [
                {
                    label: 'Learn More (Electron)',
                    click: async () => {
                        await electron_1.shell.openExternal('https://electronjs.org');
                    }
                }
            ]
        }
    ];
    const menu = electron_1.Menu.buildFromTemplate(template);
    electron_1.Menu.setApplicationMenu(menu);
    console.log("Application menu created and set.");
}
// --- Main Window Creation Function ---
function createWindow() {
    console.log('Creating main window...');
    mainWindow = new electron_1.BrowserWindow({
        width: 1200, // Initial width (will be overridden by fullscreen)
        height: 800, // Initial height (will be overridden by fullscreen)
        fullscreen: true,
        webPreferences: {
            preload: node_path_1.default.join(__dirname, '../preload/index.js'),
            nodeIntegration: false,
            contextIsolation: true,
        },
    });
    const isDev = !electron_1.app.isPackaged;
    const VITE_DEV_SERVER_URL = 'http://localhost:5173';
    console.log(`>>> DEBUG: app.isPackaged = ${electron_1.app.isPackaged}, therefore isDev = ${isDev}`);
    if (isDev && VITE_DEV_SERVER_URL) {
        console.log(`Loading DEV URL: ${VITE_DEV_SERVER_URL}`);
        mainWindow.loadURL(VITE_DEV_SERVER_URL)
            .catch(err => console.error('Failed to load DEV URL:', err));
    }
    else {
        console.log('Loading PROD build file');
        const prodPath = node_path_1.default.join(__dirname, '..', 'renderer', 'index.html');
        console.log(`Attempting to load production file: ${prodPath}`);
        mainWindow.loadFile(prodPath)
            .catch(err => console.error(`Failed to load PROD file: ${prodPath}`, err));
    }
    // --- Window Event Handlers ---
    mainWindow.webContents.setWindowOpenHandler(({ url }) => {
        if (url.startsWith('http:') || url.startsWith('https:')) {
            electron_1.shell.openExternal(url);
        }
        return { action: 'deny' };
    });
    mainWindow.webContents.on('render-process-gone', (_event, details) => {
        console.error('Renderer process gone:', details);
    });
    mainWindow.webContents.on('did-fail-load', (_event, errorCode, errorDescription, validatedURL) => {
        console.error(`Failed to load URL: ${validatedURL}, ErrorCode: ${errorCode}, Description: ${errorDescription}`);
    });
    mainWindow.on('closed', () => {
        console.log('Main window closed.');
        console.log(`Main window closed. Killing ${ptyInstances.size} PTY process(es).`);
        ptyInstances.forEach((pty, id) => {
            console.log(`Killing PTY process ID: ${id} (PID: ${pty.pid})`);
            try {
                pty.kill();
            }
            catch (e) {
                console.warn(`Error killing PTY ID ${id}:`, e);
            }
        });
        ptyInstances.clear();
        mainWindow = null;
    });
}
// --- Function to Kill a Specific PTY Process ---
function killPtyProcess(id) {
    const ptyProcess = ptyInstances.get(id);
    if (ptyProcess) {
        console.log(`Killing PTY process ID: ${id} (PID: ${ptyProcess.pid})`);
        try {
            ptyProcess.kill();
        }
        catch (e) {
            console.warn(`Error killing PTY ID ${id}:`, e);
        }
        finally {
            ptyInstances.delete(id);
            console.log(`PTY process ID: ${id} removed from map.`);
        }
    }
    else {
        console.warn(`Attempted to kill PTY process ID: ${id}, but it was not found in the map.`);
    }
}
// --- Function to Setup IPC Handlers ---
function setupIpcHandlers() {
    console.log('Setting up IPC Handlers...');
    // Basic Ping Example
    electron_1.ipcMain.handle('ping', () => 'pong from main!');
    // --- PTY Handlers ---
    electron_1.ipcMain.handle('pty-create', async (_event, options) => {
        if (!mainWindow) {
            console.error("Cannot create PTY: mainWindow is not available.");
            return { success: false, error: "Main window not available." };
        }
        const targetWebContents = mainWindow.webContents;
        const { id, cols, rows } = options;
        if (!id) {
            console.error("Cannot create PTY: Missing required 'id'.");
            return { success: false, error: "Missing terminal ID." };
        }
        if (ptyInstances.has(id)) {
            console.warn(`PTY process with ID ${id} already exists. Killing old one.`);
            killPtyProcess(id);
        }
        console.log(`Creating PTY process for ID: ${id}, shell: ${shellPath}, cols: ${cols}, rows: ${rows}`);
        try {
            const cwd = process.env.HOME || process.env.USERPROFILE || process.cwd();
            console.log(`PTY (ID: ${id}) current working directory: ${cwd}`);
            const newPtyProcess = pty.spawn(shellPath, [], {
                name: 'xterm-color',
                cols: cols || 80,
                rows: rows || 24,
                cwd: cwd,
                env: { ...process.env },
            });
            console.log(`PTY process created successfully for ID: ${id} (PID: ${newPtyProcess.pid}). Storing in map.`);
            ptyInstances.set(id, newPtyProcess);
            newPtyProcess.onData(data => {
                if (targetWebContents && !targetWebContents.isDestroyed()) {
                    targetWebContents.send('pty-data', id, data);
                }
            });
            newPtyProcess.onExit(({ exitCode, signal }) => {
                console.log(`PTY process ID: ${id} (PID: ${newPtyProcess.pid}) exited with code: ${exitCode}, signal: ${signal}`);
                if (targetWebContents && !targetWebContents.isDestroyed()) {
                    targetWebContents.send('pty-exit', id, exitCode);
                    if (exitCode !== 0 || signal) {
                        targetWebContents.send('pty-error', id, `Process exited abnormally (Code: ${exitCode}, Signal: ${signal})`);
                    }
                }
                ptyInstances.delete(id);
                console.log(`PTY process ID: ${id} removed from map due to exit.`);
            });
            return { success: true };
        }
        catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            console.error(`Failed to create PTY process for ID ${id}:`, error);
            if (targetWebContents && !targetWebContents.isDestroyed()) {
                targetWebContents.send('pty-error', id, `Failed to spawn PTY: ${errorMsg}`);
            }
            if (ptyInstances.has(id)) {
                ptyInstances.delete(id);
            }
            return { success: false, error: errorMsg };
        }
    });
    electron_1.ipcMain.on('pty-input', (_event, id, data) => {
        const ptyProcess = ptyInstances.get(id);
        if (ptyProcess) {
            try {
                ptyProcess.write(data);
            }
            catch (error) {
                const errorMsg = error instanceof Error ? error.message : String(error);
                console.error(`Error writing to PTY ID ${id} (PID: ${ptyProcess.pid}):`, error);
                mainWindow?.webContents.send('pty-error', id, `Write Error: ${errorMsg}`);
            }
        }
    });
    electron_1.ipcMain.on('pty-resize', (_event, id, options) => {
        const ptyProcess = ptyInstances.get(id);
        if (ptyProcess) {
            if (options.cols > 0 && options.rows > 0) {
                try {
                    ptyProcess.resize(options.cols, options.rows);
                }
                catch (error) {
                    const errorMsg = error instanceof Error ? error.message : String(error);
                    console.error(`Failed to resize PTY ID ${id} (PID: ${ptyProcess.pid}):`, error);
                    mainWindow?.webContents.send('pty-error', id, `Resize Error: ${errorMsg}`);
                }
            }
            else {
                console.warn(`Received invalid resize dimensions for PTY ID ${id}: cols=${options.cols}, rows=${options.rows}`);
            }
        }
    });
    electron_1.ipcMain.handle('pty-kill', async (_event, id) => {
        console.log(`IPC Request: Kill PTY ID: ${id}`);
        if (!id) {
            console.error("Cannot kill PTY: Missing required 'id'.");
            return { success: false, error: "Missing terminal ID." };
        }
        try {
            killPtyProcess(id);
            return { success: true };
        }
        catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            console.error(`Error processing kill request for PTY ID ${id}:`, error);
            return { success: false, error: errorMsg };
        }
    });
    // --- Dialog Handler ---
    electron_1.ipcMain.handle('dialog:openDirectory', async () => {
        if (!mainWindow)
            return null;
        const { canceled, filePaths } = await electron_1.dialog.showOpenDialog(mainWindow, {
            properties: ['openDirectory']
        });
        if (canceled || filePaths.length === 0) {
            return null;
        }
        else {
            console.log(`Directory selected: ${filePaths[0]}`);
            return filePaths[0];
        }
    });
    // --- File System Handlers ---
    // Read Directory Handler
    electron_1.ipcMain.handle('fs:readDirectory', async (_event, folderPath) => {
        console.log(`IPC Request: Reading directory - ${folderPath}`);
        try {
            if (!folderPath || typeof folderPath !== 'string') {
                throw new Error("Invalid folder path provided.");
            }
            const stats = await promises_1.default.stat(folderPath);
            if (!stats.isDirectory()) {
                throw new Error(`Path is not a directory: ${folderPath}`);
            }
            const dirents = await promises_1.default.readdir(folderPath, { withFileTypes: true });
            const entries = dirents.map(dirent => ({
                name: dirent.name,
                path: node_path_1.default.join(folderPath, dirent.name),
                isDirectory: dirent.isDirectory(),
            }));
            entries.sort((a, b) => {
                if (a.isDirectory && !b.isDirectory)
                    return -1;
                if (!a.isDirectory && b.isDirectory)
                    return 1;
                return a.name.localeCompare(b.name);
            });
            console.log(`IPC Success: Read ${entries.length} entries from ${folderPath}`);
            return { success: true, entries: entries };
        }
        catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            console.error(`IPC Error: Failed to read directory ${folderPath}:`, errorMsg);
            if (error instanceof Error && 'code' in error) {
                if (error.code === 'EACCES')
                    return { success: false, error: `Permission denied: ${folderPath}` };
                if (error.code === 'ENOENT')
                    return { success: false, error: `Directory not found: ${folderPath}` };
            }
            return { success: false, error: errorMsg };
        }
    });
    // Read File Handler
    electron_1.ipcMain.handle('fs:readFile', async (_event, filePath) => {
        console.log(`IPC Request: Reading file - ${filePath}`);
        try {
            if (!filePath || typeof filePath !== 'string') {
                throw new Error("Invalid file path provided.");
            }
            const stats = await promises_1.default.stat(filePath);
            if (!stats.isFile()) {
                throw new Error(`Path is not a file: ${filePath}`);
            }
            const content = await promises_1.default.readFile(filePath, { encoding: 'utf-8' });
            console.log(`IPC Success: Read file ${filePath}`);
            return { success: true, content: content };
        }
        catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            console.error(`IPC Error: Failed to read file ${filePath}:`, errorMsg);
            if (error instanceof Error && 'code' in error) {
                if (error.code === 'EACCES')
                    return { success: false, error: `Permission denied: ${filePath}` };
                if (error.code === 'ENOENT')
                    return { success: false, error: `File not found: ${filePath}` };
            }
            return { success: false, error: errorMsg };
        }
    });
    // Save File Handler
    electron_1.ipcMain.handle('fs:saveFile', async (_event, filePath, content) => {
        // *** ADDED LOGS ***
        console.log(`[Main IPC -> fs:saveFile] Received save request for: ${filePath}`);
        console.log(`[Main IPC -> fs:saveFile] Received content length: ${content?.length ?? 'undefined'}`);
        console.log(`[Main IPC -> fs:saveFile] Received content start:`, content?.substring(0, 50) + '...');
        try {
            if (!filePath || typeof filePath !== 'string') {
                throw new Error("Invalid file path provided.");
            }
            if (content === undefined || content === null) {
                throw new Error("Invalid content provided for saving.");
            }
            await promises_1.default.writeFile(filePath, content, { encoding: 'utf-8' });
            // *** MODIFIED LOG ***
            console.log(`[Main IPC -> fs:saveFile] fs.writeFile SUCCEEDED for ${filePath}. Returning { success: true }`);
            return { success: true };
        }
        catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            // *** MODIFIED LOG ***
            console.error(`[Main IPC -> fs:saveFile] fs.writeFile FAILED for ${filePath}:`, errorMsg);
            if (error instanceof Error && 'code' in error) {
                if (error.code === 'EACCES')
                    return { success: false, error: `Permission denied: ${filePath}` };
                if (error.code === 'ENOENT')
                    return { success: false, error: `Directory not found for file: ${filePath}` }; // Or similar
            }
            // *** ADDED LOG ***
            console.log(`[Main IPC -> fs:saveFile] Returning { success: false, error: ${errorMsg} }`);
            return { success: false, error: errorMsg };
        }
    });
    // --- App/Window Control Handlers ---
    electron_1.ipcMain.handle('app:quit', () => {
        console.log("IPC: Received app:quit request.");
        electron_1.app.quit();
    });
    electron_1.ipcMain.handle('window:toggle-fullscreen', () => {
        if (mainWindow) {
            const isFullScreen = mainWindow.isFullScreen();
            console.log(`IPC: Toggling fullscreen (currently ${isFullScreen}).`);
            mainWindow.setFullScreen(!isFullScreen);
        }
        else {
            console.warn("IPC: Cannot toggle fullscreen, mainWindow not found.");
        }
    });
    electron_1.ipcMain.handle('window:toggle-devtools', () => {
        if (mainWindow) {
            console.log("IPC: Toggling DevTools.");
            mainWindow.webContents.toggleDevTools();
        }
        else {
            console.warn("IPC: Cannot toggle DevTools, mainWindow not found.");
        }
    });
    console.log('IPC Handlers registered (including multi-PTY support and app/window controls).');
}
// --- App Lifecycle Events ---
electron_1.app.whenReady().then(() => {
    console.log('App is ready.');
    setupIpcHandlers();
    createApplicationMenu();
    createWindow();
    electron_1.app.on('activate', () => {
        if (electron_1.BrowserWindow.getAllWindows().length === 0) {
            console.log('App activated, creating window.');
            createWindow();
        }
    });
});
electron_1.app.on('window-all-closed', () => {
    console.log('All windows closed.');
    if (process.platform !== 'darwin') {
        electron_1.app.quit();
    }
});
electron_1.app.on('will-quit', () => {
    console.log(`App will quit. Killing ${ptyInstances.size} PTY process(es).`);
    ptyInstances.forEach((pty, id) => {
        console.log(`Killing PTY process ID: ${id} (PID: ${pty.pid})`);
        try {
            pty.kill();
        }
        catch (e) {
            console.warn(`Error killing PTY ID ${id}:`, e);
        }
    });
    ptyInstances.clear();
});
process.on('uncaughtException', (error) => {
    console.error('Uncaught Main Process Exception:', error);
    if (error.message.includes('EPIPE')) {
        console.warn("Ignoring EPIPE error in main process.");
        return;
    }
    electron_1.dialog.showErrorBox('Unhandled Main Process Error', `${error.name}: ${error.message}\n${error.stack ?? ''}`);
});
// --- END FILE: src/main/index.ts ---
--- END FILE: dist-electron/main/index.js ---

--- START FILE: dist-electron/main/index.d.ts ---
export {};
--- END FILE: dist-electron/main/index.d.ts ---

--- START FILE: dist-electron/shared.types.js ---
"use strict";
// --- START FILE: src/shared.types.ts ---
// src/shared.types.ts
Object.defineProperty(exports, "__esModule", { value: true });
// Example:
// export interface UserPreferences {
//   theme: string;
//   fontSize: number;
// }
// --- END FILE: src/shared.types.ts ---
--- END FILE: dist-electron/shared.types.js ---

--- START FILE: dist-electron/preload/index.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// --- START FILE: src/preload/index.ts ---
// src/preload/index.ts
const electron_1 = require("electron");
// --- Implementation of the API ---
const api = {
    ping: () => electron_1.ipcRenderer.invoke('ping'),
    // Terminal methods (MODIFIED)
    term_create: (options) => electron_1.ipcRenderer.invoke('pty-create', options),
    term_write: (id, data) => electron_1.ipcRenderer.send('pty-input', id, data), // Send ID
    term_resize: (id, options) => electron_1.ipcRenderer.send('pty-resize', id, options), // Send ID
    term_kill: (id) => electron_1.ipcRenderer.invoke('pty-kill', id), // New invoke
    // Terminal listeners (MODIFIED - expect ID as first arg from main)
    term_onData: (callback) => {
        const subscription = (_event, id, data) => callback(id, data);
        electron_1.ipcRenderer.on('pty-data', subscription);
        // Return a function to unsubscribe
        return () => {
            electron_1.ipcRenderer.removeListener('pty-data', subscription);
            console.log("Preload: Unsubscribed from pty-data"); // DEBUG
        };
    },
    term_onExit: (callback) => {
        const subscription = (_event, id, code) => callback(id, code);
        electron_1.ipcRenderer.on('pty-exit', subscription);
        // Return a function to unsubscribe
        return () => {
            electron_1.ipcRenderer.removeListener('pty-exit', subscription);
            console.log("Preload: Unsubscribed from pty-exit"); // DEBUG
        };
    },
    term_onError: (callback) => {
        const subscription = (_event, id, errorMessage) => callback(id, errorMessage);
        electron_1.ipcRenderer.on('pty-error', subscription);
        // Return a function to unsubscribe
        return () => {
            electron_1.ipcRenderer.removeListener('pty-error', subscription);
            console.log("Preload: Unsubscribed from pty-error"); // DEBUG
        };
    },
    // Dialog methods (Unchanged)
    dialog_openDirectory: () => electron_1.ipcRenderer.invoke('dialog:openDirectory'),
    // File System Methods (Unchanged)
    fs_readDirectory: (folderPath) => electron_1.ipcRenderer.invoke('fs:readDirectory', folderPath),
    fs_readFile: (filePath) => electron_1.ipcRenderer.invoke('fs:readFile', filePath),
    fs_saveFile: (filePath, content) => electron_1.ipcRenderer.invoke('fs:saveFile', filePath, content),
    // App/Window Control Methods (Unchanged)
    app_quit: () => electron_1.ipcRenderer.invoke('app:quit'),
    window_toggleFullscreen: () => electron_1.ipcRenderer.invoke('window:toggle-fullscreen'),
    window_toggleDevTools: () => electron_1.ipcRenderer.invoke('window:toggle-devtools'),
};
// --- Expose the API to the Renderer process ---
try {
    electron_1.contextBridge.exposeInMainWorld('electronAPI', api);
    console.log('Preload script exposed electronAPI successfully (including multi-terminal and app/window controls).');
}
catch (error) {
    console.error('Error exposing context bridge in preload script:', error);
}
// --- END FILE: src/preload/index.ts ---
--- END FILE: dist-electron/preload/index.js ---

--- START FILE: dist-electron/preload/index.d.ts ---
import type { ReadDirectoryResponse, ReadFileResponse, SaveFileResponse, PtyCreateOptions, PtyResizeOptions, PtyCreateResponse } from '../shared.types';
export interface ElectronAPI {
    ping: () => Promise<string>;
    term_create: (options: PtyCreateOptions) => Promise<PtyCreateResponse>;
    term_write: (id: string, data: string) => void;
    term_resize: (id: string, options: PtyResizeOptions) => void;
    term_kill: (id: string) => Promise<{
        success: boolean;
        error?: string;
    }>;
    term_onData: (callback: (id: string, data: string) => void) => () => void;
    term_onExit: (callback: (id: string, code?: number) => void) => () => void;
    term_onError: (callback: (id: string, errorMessage: string) => void) => () => void;
    dialog_openDirectory: () => Promise<string | null>;
    fs_readDirectory: (folderPath: string) => Promise<ReadDirectoryResponse>;
    fs_readFile: (filePath: string) => Promise<ReadFileResponse>;
    fs_saveFile: (filePath: string, content: string) => Promise<SaveFileResponse>;
    app_quit: () => Promise<void>;
    window_toggleFullscreen: () => Promise<void>;
    window_toggleDevTools: () => Promise<void>;
}
--- END FILE: dist-electron/preload/index.d.ts ---

