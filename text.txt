Okay, here is a prompt you can use to continue this session later or with another AI instance. It summarizes the current state and outlines the next steps based on our conversation and your V1 goals.

---

**Continuation Prompt for CodeCraft IDE Development**

**Project:** CodeCraft IDE - A desktop IDE using Electron, React, TypeScript.

**Current Status:**
We have successfully set up the development environment using a manual Vite configuration (no Electron Forge template in use currently) with a multi-terminal workflow:
1.  Terminal 1: `npm run build:main -- --watch` (Compiles `src/main` and `src/preload` via `tsc --project tsconfig.node.json`)
2.  Terminal 2: `npm run dev` (Runs Vite dev server via `vite --config vite.config.mjs`)
3.  Terminal 3: `npx electron .` (Launches the Electron app)

The application structure includes:
*   **Main Process (`src/main/index.ts`):** Handles window creation, IPC, and `node-pty` management. Compiles to CommonJS. Hardware acceleration is disabled (for WSL compatibility).
*   **Preload Script (`src/preload/index.ts`):** Exposes an `electronAPI` via `contextBridge` for IPC. Compiles to CommonJS.
*   **Renderer Process (`src/renderer`):** Uses React and TypeScript. Bundled by Vite.
    *   **Layout:** A basic 3-panel layout (`Sidebar`, `EditorPanel`, `TerminalPanel`) managed by `App.tsx` and styled using CSS variables (`index.css`, `App.css`).
    *   **Editor Panel:** Currently renders a functional Monaco Editor instance using `react-monaco-editor`. Basic default content is shown.
    *   **Terminal Panel:** Renders a functional Xterm.js terminal using manual `Terminal` instantiation (not the `react-xtermjs` component wrapper due to type issues). Basic styling and `FitAddon` are implemented.
    *   **IPC:** Basic `ping` works. Crucially, the IPC bridge for the terminal (`pty-create`, `pty-input`, `pty-resize`, `pty-data`, `pty-exit`) is **implemented and functional**. Users can type commands into the frontend terminal, have them executed by `node-pty` in the main process, and see the output streamed back. Resizing via `FitAddon` and IPC seems to be working, although potentially needs refinement.

**Key Dependencies Installed:** `electron`, `react`, `typescript`, `vite`, `monaco-editor`, `react-monaco-editor`, `xterm`, `xterm-addon-fit`, `node-pty`.

**V1 Goals Recap:** Monaco Editor, File Tree/Management, Integrated Terminal (xterm+node-pty), Theming (VS Code compatible).

**Next Steps to Implement:**

1.  **File Management (Core Functionality):**
    *   **Sidebar UI:** Replace the "Placeholder for file tree" in `Sidebar.tsx` with a basic file/folder listing component.
    *   **Open Folder:** Add a mechanism (e.g., button, menu item via main process) to select a folder. Use IPC to send the selected path to the main process.
    *   **Read Directory:** Implement an IPC handler in `main/index.ts` (e.g., `read-directory`) that uses Node.js `fs` module to read the contents of the selected folder path. Send the file/folder list back to the renderer.
    *   **Display Tree:** Populate the Sidebar component with the received file/folder list. Make it expandable/collapsible.
    *   **Read File:** Add an IPC handler (`read-file`) in `main/index.ts` to read the content of a selected file path.
    *   **Load in Editor:** When a file is clicked in the Sidebar, trigger the `read-file` IPC call. Receive the content in the renderer and update the Monaco Editor's value (`setCode(...)` in `EditorPanel.tsx`). Detect file type and set Monaco's language accordingly.
    *   **Save File:** Add an IPC handler (`save-file`) in `main/index.ts`. Add a save mechanism (e.g., Ctrl+S listener, button) in the renderer that sends the current editor content and file path via IPC to be saved using `fs`.
    *   **(Optional V1+)** Implement tabs for multiple open files in `EditorPanel`.

2.  **Theming System:**
    *   Implement a simple theme switcher (e.g., a button or dropdown) in the UI.
    *   Modify `index.css` to include variable definitions for a dark theme under a specific class (e.g., `.theme-dark`).
    *   Use React state to toggle the theme class on the root HTML element or a top-level container.
    *   **(Later)** Investigate loading theme colors from VS Code `.json` theme files via the main process.

3.  **Terminal Refinements:**
    *   Improve resize robustness if needed.
    *   Handle the `pty-exit` event more visually (e.g., display message prominently, disable input).
    *   Add a "clear terminal" button/command (send IPC message, main process sends control code like `\x1bc` or `\x0c` to pty).

4.  **Editor Enhancements:**
    *   Configure more Monaco options (minimap, word wrap, etc.).
    *   Indicate unsaved changes.

**Question:** Which of these next steps (primarily focusing on File Management or Theming) should we work on first?

---